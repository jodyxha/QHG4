// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  File: avtPieFilter.C
// ****************************************************************************

#include <sstream>
#include <avtPieFilter.h>
#include <avtDataTree.h>
#include <vtkPolyData.h>
#include <vtkDataSet.h>
#include <vtkPoints.h>
#include <vtkPointData.h>
#include <vtkDataArray.h>
#include <vtkDoubleArray.h>
#include <vtkTriangle.h>

#include <DebugStream.h>
#include <vtkStringArray.h>

// ****************************************************************************
//  Method: avtPieFilter constructor
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtPieFilter::avtPieFilter()
{
    debug1 << "QHG: [avtPieFilter::avtPieFilter]" << endl<< std::flush;
 }


// ****************************************************************************
//  Method: avtPieFilter destructor
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtPieFilter::~avtPieFilter()
{
    debug1 << "QHG: [avtPieFilter::~avtPieFilter]" << endl;
}



// ****************************************************************************
//  Method: avtPieFilter::ExecuteDataTree
//
//  Purpose:
//      Creates a data tree whose leaves contain the data for the single glyphs
//      (currently the glyphs can be pieplots, bardiagrams and boxes)
//
//  Arguments:
//      in_dr     The input data representation.
//
//  Returns:      The output data tree.
//
//  Programmer: jody
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************
avtDataTree_p
avtPieFilter::ExecuteDataTree(avtDataRepresentation *in_dr)
{
    //
    // Get the VTK data set, the domain number, and the label.
    //
    vtkDataSet *in_ds = in_dr->GetDataVTK();
    int domain = in_dr->GetDomain();
    std::string label = in_dr->GetLabel();

    vtkDataSet *pPieDS = NULL;

    // The incoming data tree (from the file reader) has a single leaf:
    // a data set with a single array on num_pies*(6+num_vals) elements.
    // Each pie is characterised by position, notmal, and a number of arbitrary nonnegative numbers.
    avtDataTree_p pOrigTree = GetInputDataTree();
    int iNumArrays = 0;
    vtkDataSet **ppArrays = pOrigTree->GetAllLeaves(iNumArrays);
    debug1 << "QHG: [avtPieFilter::ExecuteDataTree] got " << iNumArrays << " " <<((iNumArrays == 1)?"Leaf":" Leaves") << endl << std::flush;
 
    // later versions might have relative scales in he file
    double default_scale[3] = {1.0,1.0,1.0};

    // get the array
    vtkDataSet *curDS = ppArrays[0];
    vtkPointData *pPointData = curDS->GetPointData();
    // collect the data (passed as an array of (6+NV)-tuples
    vtkDataArray *pDataArray = pPointData->GetArray(0);
    int iNumTuples = pDataArray->GetNumberOfTuples();
    int iNumComp = pDataArray->GetNumberOfComponents();
    char *pName = pDataArray->GetName();
    debug1 << "QHG: [avtPieFilter::ExecuteDataTree] got name[" << pName <<"]"<<endl<<std::flush;
            
    // now build a tree holding the subarrays for the pies
    int nGlyphs          = iNumTuples;
    debug1 << "QHG: [avtPieFilter::ExecuteDataTree]   making tree for " << nGlyphs << " vtkDataSet objects" << endl << std::flush;
    vtkDataSet **sets    = new vtkDataSet*[nGlyphs];
    std::vector<std::string> vlabels;
    std::vector<int>         vindexes;
    std::stringstream ss;
            
    for (int i = 0; i < nGlyphs; i++) {

        // build a 'dummy' PolyData: single vertex at the glyphs position
        // to which we attach the data
        double *pData = pDataArray->GetTuple(i);
        // the first 3 elements are the position
        vtkPolyData *pPoly = vtkPolyData::New();
        vtkPoints   *newPoints = vtkPoints::New();
        newPoints->SetDataType(VTK_DOUBLE);
        newPoints->Allocate(1);
        newPoints->InsertNextPoint(pData[0], pData[1],   pData[2]);
        vtkIdType idx[1] = {0};
        pPoly->Allocate(1);
        pPoly->InsertNextCell(VTK_VERTEX, 1, idx);
        pPoly->SetPoints(newPoints);

        //  
        sets[i] = pPoly;
        // cretae unique label
        ss << label << "_" << std::setw(3) << std::setfill('0') << i;
        vlabels.push_back(ss.str().c_str());
        vindexes.push_back(i);
 
        //  we send along pos, norm and scale as field data arrays
        vtkFieldData *pFieldData = sets[i]->GetFieldData();
                
        // position coords start at index 0
        vtkDoubleArray *rvPos = vtkDoubleArray::New();
        rvPos->SetNumberOfComponents(3);
        rvPos->SetNumberOfTuples(1);
        rvPos->SetTuple(0, pData);
        std::string sNamePos = "pos";
        rvPos->SetName(sNamePos.c_str());
        pFieldData->AddArray(rvPos);
     
        // norm coords start at index 3
        vtkDoubleArray *rvNorm = vtkDoubleArray::New();
        rvNorm->SetNumberOfComponents(3);
        rvNorm->SetNumberOfTuples(1);
        rvNorm->SetTuple(0, pData+3);
        std::string sNameNorm = "norm";
        rvNorm->SetName(sNameNorm.c_str());
        pFieldData->AddArray(rvNorm);

        // scales are not (yet) part of the pie data format
        // so we use the default scale (1.0,1.0,1.0)
        vtkDoubleArray *rvScale = vtkDoubleArray::New();
        rvScale->SetNumberOfComponents(3);
        rvScale->SetNumberOfTuples(1);
        rvScale->SetTuple(0, default_scale);
        std::string sNameScale = "scale";
        rvScale->SetName(sNameScale.c_str());
        pFieldData->AddArray(rvScale);
               
        // values start at index 6
        vtkDoubleArray *rvVals = vtkDoubleArray::New();
        rvVals->SetNumberOfComponents(iNumComp-6);
        rvVals->SetNumberOfTuples(1);
        rvVals->SetTuple(0, pData+6);
        std::string sNameValue = "vals";
        rvVals->SetName(sNameValue.c_str());
        pFieldData->AddArray(rvVals);

        // prepare default value names in case no component names have been set
        std::vector< std::string> vTempNames;
        char sItem[64];
        for (uint j = 0; j < iNumComp; j++) {
            sprintf(sItem, "item_%02d", j);
            vTempNames.push_back(sItem);
        }
        vtkStringArray *rvNames = vtkStringArray::New();
        if (pDataArray->HasAComponentName()) {  
            for (uint j = 6; j < iNumComp; j++) {
                rvNames->InsertValue(j-6, pDataArray->GetComponentName(j));
            }
        } else {
            for (uint j = 0; j < vTempNames.size(); j++) {
                rvNames->InsertValue(j, vTempNames[j]);
            }
        }

        bool bShowDetails = false;
        if (bShowDetails) {
            if (pDataArray->HasAComponentName()) {  
                debug1 << "QHG: [avtPieFilter::ExecuteDataTree] adding real names"<<endl<<std::flush;
                for (uint j = 6; j < iNumComp; j++) {
                    debug1 << "QHG: [avtPieFilter::ExecuteDataTree]    " << pDataArray->GetComponentName(j) <<endl<<std::flush;
                }
            } else {
                debug1 << "QHG: [avtPieFilter::ExecuteDataTree] adding fake names"<<endl<<std::flush;
                for (uint j = 0; j < vTempNames.size(); j++) {
                    debug1 << "QHG: [avtPieFilter::ExecuteDataTree]    " << vTempNames[j] <<endl<<std::flush;
                }
            }
        }

        std::string sNameName = "names";
        rvNames->SetName(sNameName.c_str());
        pFieldData->AddArray(rvNames);
        
        vtkStringArray *rvFamily = vtkStringArray::New();
        rvFamily->InsertValue(0, pName);
        std::string sFamilyName = "family";
        rvFamily->SetName(sFamilyName.c_str());
        pFieldData->AddArray(rvFamily);
        
        //        debug1 << "QHG: [avtPieFilter::ExecuteDataTree] sets[" << i << "] completed" << endl << std::flush;
    }

    // now create the tree from the array of datasets
    avtDataTree_p pNewTree = new avtDataTree(nGlyphs, sets, vindexes, vlabels);
    // we must do this in order to prevent the merging of the leaves
    GetOutput()->GetInfo().GetAttributes().SetLabels(vlabels);
    debug1 << "QHG: [avtPieFilter::ExecuteDataTree] the completed tree has " << pNewTree->GetNChildren() << " children" << endl << std::flush;
    
    delete[] ppArrays;

    return pNewTree;
}


// ****************************************************************************
//  Method: avtPieFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

void
avtPieFilter::UpdateDataObjectInfo(void)
{
    debug1 << "QHG: [avtPieFilter::UpdateDataObjectInfo]" << endl;
    //@@IF YOU SEE FUNNY THINGS WITH EXTENTS, ETC, YOU CAN CHANGE THAT HERE.
}


// ****************************************************************************
// Method: avtLabelFilter::ModifyContract
//
// Purpose: 
//     Modify the avtContract.
//
// Arguments:
//     contract    an avtContract pointer. 
//
// Returns:    
//     contract    an avtContract pointer. 
//
// Programmer: Alister Maguire
// Creation:   Fri Feb 23 16:19:18 PST 2018
//
// Modifications:
//
// ****************************************************************************

avtContract_p
avtPieFilter::ModifyContract(avtContract_p contract)
{
    //
    // If we have mixed variables, we need to force MIR to 
    // gain access to the subset array. 
    //
    debug1 << "QHG: [avtPieFilter::ModifyContract]" << endl;
    if (contract->GetDataRequest()->NeedMixedVariableReconstruction())
    {
        contract->GetDataRequest()->ForceMaterialInterfaceReconstructionOn();
    }
    return contract;
}

