// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  File: avtPiePlot.C
// ****************************************************************************

#include <avtPiePlot.h>
#include <avtPieMapper.h>

#include <avtPieFilter.h>

#include <avtLevelsLegend.h>
#include <avtLookupTable.h>

#include <DebugStream.h>

#include "PieAttributes.h"
#include "GlyphColors.h"
#include "GlyphManager.h"

// ****************************************************************************
//  Method: avtPiePlot constructor
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtPiePlot::avtPiePlot()
{
    debug1 << "QHG: [avtPiePlot::avtPiePlot] (" << this << ")" << endl << std::flush;

    m_pGM = GlyphManager::createInstance();

    pPieFilter  = new avtPieFilter();
    pPieMapper  = new avtPieMapper(m_pGM);

    levelsLegend  = new avtLevelsLegend;
    levelsLegend->SetTitle("PiePlot");
    avtLUT        = new avtLookupTable;
    iNumValues    = 0;

    levLegendRefPtr = levelsLegend;
    m_vCurColors.clear();

}


// ****************************************************************************
//  Method: avtPiePlot destructor
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtPiePlot::~avtPiePlot()
{
    debug1 << "QHG: [avtPiePlot::~avtPiePlot] (" << this << ")" << endl << std::flush;
    if (pPieMapper != NULL)
    {
        delete pPieMapper;
        pPieMapper = NULL;
    }
    if (pPieFilter != NULL)
    {
        delete pPieFilter;
        pPieFilter = NULL;
    }

    if (avtLUT != NULL)
    {
        delete avtLUT;
        avtLUT = NULL;
    }

    //
    // Do not delete the levelsLegend since it is being held by levLegendRefPtr.
    //

}


// ****************************************************************************
//  Method:  avtPiePlot::Create
//
//  Purpose:
//    Call the constructor.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtPlot*
avtPiePlot::Create()
{
    debug1 << "QHG: [avtPiePlot::Create]" << endl << std::flush;
    return new avtPiePlot;
}


// ****************************************************************************
//  Method: avtPiePlot::GetMapper
//
//  Purpose:
//      Gets a mapper for this plot, it is actually a variable mapper.
//
//  Returns:    The variable mapper typed as its base class mapper.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtMapperBase *
avtPiePlot::GetMapper(void)
{
    return pPieMapper;
}


// ****************************************************************************
//  Method: avtPiePlot::ApplyOperators
//
//  Purpose:
//      Applies the operators associated with a Pie plot.  
//      The output from this method is a query-able object.
//      (Don't know if piping through PieFilter is necessary)
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the Pie plot has been applied.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtDataObject_p
avtPiePlot::ApplyOperators(avtDataObject_p input)
{
    debug1 << "QHG: [avtPiePlot::ApplyOperators]" << endl << std::flush;
    
    pPieFilter->SetInput(input);
    return pPieFilter->GetOutput();
    
}


// ****************************************************************************
//  Method: avtPiePlot::ApplyRenderingTransformation
//
//  Purpose:
//      Applies the rendering transformation associated with a Pie plot.  
//      (We don't actually need this method; so we simply pass the input to the output)
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the Pie plot has been applied.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************

avtDataObject_p
avtPiePlot::ApplyRenderingTransformation(avtDataObject_p input)
{
    debug1 << "QHG: [avtPiePlot::ApplyRenderingTransformation]" << endl;
    return input;
}


// ****************************************************************************
//  Method: avtPiePlot::CustomizeBehavior
//
//  Purpose:
//      Customizes the behavior as appropriate for a Pie plot.
//      Here we do some legend preparations (taken from avtContourPlot::CustomizeBehavior)
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************
void
avtPiePlot::CustomizeBehavior(void)
{
    debug1 << "QHG: [avtPiePlot::CustomizeBehavior]" << endl << std::flush;

    iNumValues = pPieMapper->getNumValues();
    
    levelsLegend->SetVarRangeVisibility(false);
    levelsLegend->SetColorBarVisibility(true);
    levelsLegend->SetReverseOrder(true);

    levelsLegend->SetLookupTable(avtLUT->GetLookupTable());
    
    levelsLegend->SetMessage(NULL);
    

    behavior->SetLegend(levLegendRefPtr);
    behavior->SetShiftFactor(0.5);
    debug1 << "QHG: [avtPiePlot::CustomizeBehavior] done" << endl << std::flush;

}


// ****************************************************************************
//  Method: avtPiePlot::CustomizeMapper
//
//  Purpose:
//    Use the info to set the value names in the legend.  
//
//  Programmer: jodyxha
//  Creation:   November 22, 2021 
//
//  Modifications:
//
// ****************************************************************************
void
avtPiePlot::CustomizeMapper(avtDataObjectInformation &info)
{
    debug1 << "QHG: [avtPiePlot::CustomizeMapper]" << endl << std::flush;

    const std::vector<std::string> &valNames = pPieMapper->getComponentNames();

    if (!valNames.empty())
    {
        debug1 << "QHG: [avtPiePlot::CustomizeMapper] setting " << valNames.size() << " names" << endl << std::flush;

        levelsLegend->SetLevels(valNames);
        levelsLegend->SetColorBarVisibility(1);
        levelsLegend->SetMessage(NULL);
    }
    else
    { 
        levelsLegend->SetColorBarVisibility(0);
        levelsLegend->SetMessage("Unable to compute levels");
        debug1 << "QHG: [avtPiePlot::CustomizeMapper] visibility 0" << endl << std::flush;
    }
    debug1 << "QHG: [avtPiePlot::CustomizeMapper] done" << endl << std::flush;

}



// ****************************************************************************
//  Method: avtPiePlot::SetAtts
//
//  Purpose:
//      Sets the atts for the Pie plot.
//
//  Arguments:
//      atts    The attributes for this Pie plot.
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************
void
avtPiePlot::SetAtts(const AttributeGroup *a)
{
    //@@BASED ON ATTRIBUTE VALUES, CHANGE PARAMETERS IN MAPPER AND FILTER.
    //    debug1 << "QHG: [avtPiePlot::SetAtts("<<a<<")]" << endl << std::flush;
    /*const*/ PieAttributes *newAtts = (/*const*/ PieAttributes *)a;

    debug1 << "QHG: [avtPiePlot::SetAtts] atts (" << newAtts <<") has " << newAtts->GetValueNames().size() << " names" <<endl << std::flush; 
    for (uint i = 0; i <   newAtts->GetValueNames().size(); i++) {
        debug1 << "QHG: [avtPiePlot::SetAtts]        [" <<  (newAtts->GetValueNames())[i] << "]" << endl << std::flush;
    }
   
    SetLegendColors(newAtts);
    levelsLegend->LegendOn(); // later make a SetLegend(bool) method

    debug1 << "QHG: [avtPiePlot::SetAtts] getting glyphstyle" <<endl << std::flush; 
    PieAttributes::GlyphStyle gs = newAtts->GetIGlyphStyle();
    debug1 << "QHG: [avtPiePlot::SetAtts] setting glyphstyle to mapper %p" << pPieMapper <<endl << std::flush; 
    pPieMapper->setGlyphType(gs);
    debug1 << "QHG: [avtPiePlot::SetAtts] gs " << gs <<endl << std::flush; 
    switch (gs) {
    case PieAttributes::STYLE_PIE: {
        int iPieSectors  = newAtts->GetIPieSectors();
        float fPieRadius = newAtts->GetFPieRadius();
        float fPieBorder = newAtts->GetFPieBorder();
        debug1 << "QHG: [avtPiePlot::SetAtts] iPieSectors " << iPieSectors<<", fPieRadius " << fPieRadius << ", fPieBorder " << fPieBorder << "(GM:"<< m_pGM << ")" <<endl << std::flush; 
        m_pGM->setPieAtts(iPieSectors, fPieRadius, fPieBorder);
        debug1 << "QHG: [avtPiePlot::SetAtts] pie atts set" <<endl << std::flush; 
        break;
    }
    case PieAttributes::STYLE_BAR: {
        float fBarXScale = newAtts->GetFBarXScale();
        float fBarYScale = newAtts->GetFBarYScale();
        float fBarBorder = newAtts->GetFBarBorder();
        debug1 << "QHG: [avtPiePlot::SetAtts] fScaleX " << fBarXScale << ", fScaleY " << fBarYScale << ", fBarBorder " << fBarBorder <<endl << std::flush; 
        m_pGM->setBarAtts(fBarXScale, fBarYScale, fBarBorder);
        break;
    }
    case PieAttributes::STYLE_BOX: {
        float fBoxXScale = newAtts->GetFBoxXScale();
        float fBoxYScale = newAtts->GetFBoxYScale();
        float fBoxBorder = newAtts->GetFBoxBorder();
        debug1 << "QHG: [avtPiePlot::SetAtts] fScaleX " << fBoxYScale << ", fScaleY " << fBoxYScale << ", fBoxBorder " << fBoxBorder <<endl << std::flush; 
        m_pGM->setBoxAtts(fBoxXScale, fBoxYScale, fBoxBorder);
        break;
    }
    default:
        debug1 << "QHG: [avtPiePlot::SetAtts] unknown style: " << gs <<endl <<std::flush;
    }

}

// ****************************************************************************
//  Method: avtPiePlot::SetLegendColors
//
//  Purpose:
//      Sets the colors to the look up table of the legend
//
//  Arguments:
//      atts    -
//
//  Programmer: jody -- generated by xml2avt
//  Creation:   Wed Oct 6 11:02:10 PDT 2021
//
// ****************************************************************************
void
avtPiePlot::SetLegendColors(PieAttributes *pNewAtts)
{

    // here (or in the calling SetAtts()) we would retrieve the color values from the dialog


    //iNumValues = pPieMapper->getNumValues();
    iNumValues = pNewAtts->GetValueNames().size();
    debug1 << "QHG: [avtPiePlot::SetColors] num values is " << iNumValues  << endl <<std::flush;
    if (iNumValues > 0) {


        const ColorAttributeList &cal = pNewAtts->GetMultiColor();
        int iC = cal.GetNumColors();
        debug1 << "QHG: [avtPiePlot::SetColors] num colors is " << iC  << endl <<std::flush;
        if (iC > 0) {

            m_vCurColors.clear();
            unsigned char *colors = new unsigned char[iNumValues * 4];
            unsigned char *cptr = colors;
            for(int i = 0; i < iNumValues; i++)         {
                unsigned char *cptr1 = cptr;

                *cptr++ = (char)cal[i%iC].Red();
                *cptr++ = (char)cal[i%iC].Green();
                *cptr++ = (char)cal[i%iC].Blue();
                *cptr++ = (char)cal[i%iC].Alpha();
                
                // my glyphs need double[4] to set their color because there seems to be no method to add/insert a char array to a vtkUnsignedCharArray
                double *dCur = new double[4];
                dCur[0] = (double)cal[i%iC].Red();
                dCur[1] = (double)cal[i%iC].Green();
                dCur[2] = (double)cal[i%iC].Blue();
                dCur[3] = (double)cal[i%iC].Alpha();
                m_vCurColors.push_back(dCur);
            }

            for(uint i = 0; i < m_vCurColors.size(); i++) {
                debug1 << "QHG: [avtPiePlot::SetColors]      vec(" << m_vCurColors[i][0] << "," << m_vCurColors[i][1] << "," << m_vCurColors[i][2] << "," << m_vCurColors[i][3] << ")"  << endl <<std::flush;
            }

            debug1 << "QHG: [avtPiePlot::SetColors] setting " << m_vCurColors.size() << " colors (should be " << iNumValues << ")" <<endl <<std::flush;
            avtLUT->SetLUTColorsWithOpacity(colors, iNumValues);
            pPieMapper->SetColors(m_vCurColors);
            debug1 << "QHG: [avtPiePlot::SetColors] mapper's colors set " <<endl <<std::flush;

            
            // Delete the temp color array.
            delete [] colors;
        } else {
            debug1 << "QHG: [avtPiePlot::SetColors] num colors are 0" <<endl <<std::flush;
        }
   

    } else {
        debug1 << "QHG: [avtPiePlot::SetColors] have 0 values" <<endl <<std::flush;
        
    }
    
    // if we got no colors, set some default colors
    if (m_vCurColors.size() == 0) {
        if (iNumValues <= 0) {
            iNumValues = 6;
        }
        m_vCurColors.clear();
        debug1 << "QHG: [avtPiePlot::SetColors] have 0 colors and " << iNumValues << " values; setting default colors" <<endl <<std::flush;
        for (int i = 0; i < sizeof(basic_colors)/(3*sizeof(double)); i++) {
            m_vCurColors.push_back(basic_colors[i]);
        }
        unsigned char *colors = new unsigned char[iNumValues * 4];
        unsigned char *cptr = colors;
        for(int i = 0; i < iNumValues; i++)         {
            *cptr++ = (char)m_vCurColors[i+1][0];
            *cptr++ = (char)m_vCurColors[i+1][1];
            *cptr++ = (char)m_vCurColors[i+1][2];
            *cptr++ = (char)m_vCurColors[i+1][3];
        }
        avtLUT->SetLUTColorsWithOpacity(colors, iNumValues);
        pPieMapper->SetColors(m_vCurColors);
        delete [] colors;
     } 

    levelsLegend->SetLookupTable(avtLUT->GetLookupTable());
    debug1 << "QHG: [avtPiePlot::SetColors] SetColors done" <<endl <<std::flush;
}

