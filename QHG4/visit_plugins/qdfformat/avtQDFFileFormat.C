/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/


// ************************************************************************* //
//                            avtQDFFileFormat.C                           //
// ************************************************************************* //

#include <avtQDFFileFormat.h>

#include <stdio.h>
#include <string>
#include <stdlib.h>

#include <vtkIntArray.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkLongArray.h>
#include <vtkUnsignedCharArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkVertex.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

#include <hdf5.h>
#include <math.h>
#include <vector>

#include <DebugStream.h>

#include "SCell.h"
#include "QDFVisitUtils.h"
#include "QDFReaderUtils.h"
#include "EQConnectivity.h"

#define SEP_CHAR "_"

#define DENSITY_NAME  "Density"
#define NUMBER_NAME   "Number"

#define CAP_NAME      "Capacity"
#define ARRIVAL_NAME  "ArrivalTime"
#define DISTANCE_NAME "Distance"
#define HOPS_NAME     "Hops"
#define HYBR_NAME     "Hybridization"
#define MEDIAN_NAME   "Medians"

using     std::string;


// ****************************************************************************
//  Method: avtQDFFileFormat constructor
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

avtQDFFileFormat::avtQDFFileFormat(const char *filename)
    : avtSTSDFileFormat(filename),
      m_hFile(H5P_DEFAULT),
      m_hGridGroup(H5P_DEFAULT),
      m_hGeoGroup(H5P_DEFAULT),
      m_hClimateGroup(H5P_DEFAULT),
      m_hVegGroup(H5P_DEFAULT),
      m_hNavGroup(H5P_DEFAULT),
      m_hPopGroup(H5P_DEFAULT),
      m_hPieGroup(H5P_DEFAULT),
      m_hVecGroup(H5P_DEFAULT),
      m_nPops(0),
      m_fMinDistance(10000000)
{
    m_initialized = false;
    strcpy(m_sFileName, filename);

    Initialize();
}

void 
avtQDFFileFormat::ActivateTimestep() {
    Initialize();
}

hid_t avtQDFFileFormat::getHandle(named_handles &mapHandles, const char *pName) {
    hid_t hResult = H5P_DEFAULT;
    named_handles::const_iterator it = mapHandles.find(pName);
    if (it != mapHandles.end()) {
        hResult = it->second;
    }
    return hResult;
}

// ****************************************************************************
//  Method: avtQDFFileFormat::findPopSubGroups
//
//  Purpose:
//      Finds the population subgroups in the QDF file
//
//  Programmer: jody
//  Creation:   Dec 2021
//  Modifications:
//
// ****************************************************************************

void avtQDFFileFormat::findPopSubGroups() {
    debug1 << "QDF: [findPopSubGroups] getting pop info in intialize... " << endl;
                    
    int iResult = H5Gget_info(m_hPopGroup, &m_infoPopGroup);
    
    if (iResult >= 0) {
        m_nPops = m_infoPopGroup.nlinks;
        debug1 << "QDF: [findPopSubGroups] Creating metadata for " << m_nPops << " populations" << endl;

        m_vPopNames.clear();
        m_mapDataAgents.clear();
        m_mapNAgents.clear();
        for (int i = 0; i < m_nPops; i++) {
            char sCurName[1024];
            H5Gget_objname_by_idx(m_hPopGroup, i, sCurName, 1024);
            m_vPopNames.push_back(sCurName);

            debug1 << "QDF: [findPopSubGroups] Pop #" << i << "::: " << sCurName << endl;
                            
            hid_t hThisPop = qdf_openGroup(m_hPopGroup, sCurName, true);
            printf("QDF: [findPopSubGroups] check existence of %s] in %lu\n", AGENT_DATASET_NAME, hThisPop);  fflush(stdout);
            if (H5Lexists(hThisPop, AGENT_DATASET_NAME, H5P_DEFAULT)) {
                m_mapAgentGroups[sCurName] = hThisPop;               
                hid_t hThisDataset = H5Dopen(hThisPop, AGENT_DATASET_NAME, H5P_DEFAULT);
                hid_t hAgentType = H5Dget_type(hThisDataset);     // get the agent compound data type
                int nFields = H5Tget_nmembers(hAgentType);        // how many data fiels are in the compound agent type?
                size_t iAgentTypeSize = H5Tget_size(hAgentType);  // get its size in bytes for later use
                hssize_t nAgents = H5Dget_storage_size(hThisDataset)/iAgentTypeSize; // how many agents?
                                
                // save valuable information for later use
                m_mapDataAgents.insert(std::pair<std::string,hid_t>(m_vPopNames[i], hThisDataset));
                m_mapNAgents.insert(std::pair<std::string, int>(m_vPopNames[i], (int)nAgents));
                debug1 << "QDF: [findPopSubGroups] added Pop data for '" << m_vPopNames[i] << ".(" << nAgents <<" agents) to  m_mapDataAgents and  m_mapNAgents" << endl;


                for (unsigned int j = 0; j < nFields; j++) {
                    char* sFieldName = new char[63];
                    sFieldName = H5Tget_member_name(hAgentType, j);  // get the name of each field
                    int iFieldOffset = H5Tget_member_offset(hAgentType, j);   // get its offset for later use
                    hid_t tFieldType = H5Tget_member_type(hAgentType, j);
                    hid_t tFieldTypeSize = H5Tget_size(tFieldType);
                                    
                    // create datatype for this data field, we need it to read the data
                    // without having to fill in a whole agent array with everything
                    hid_t tReadType = H5Tcreate(H5T_COMPOUND, tFieldTypeSize);
                    H5Tinsert(tReadType, sFieldName, 0, tFieldType);
                    
                    char* sUniqueFieldName = new char[128];
                    strcpy(sUniqueFieldName, m_vPopNames[i].c_str());
                    strcat(sUniqueFieldName, SEP_CHAR);
                    strcat(sUniqueFieldName, sFieldName);  // name = POPNAME:FIELDNAME to avoid duplication between pops
                            
                    debug1 << "QDF: [findPopSubGroups] adding metadata for " << sUniqueFieldName << endl;
                    
                    group_type pairDatasetAndType = group_type(hThisDataset, tReadType);
                    name_group pairNames = name_group(m_vPopNames[i], pairDatasetAndType);
                    m_mapAgentFields.insert(std::pair<std::string,name_group>(sUniqueFieldName, pairNames));
                    delete sFieldName;
                }
                
            }    
        }
        
    }
}

// ****************************************************************************
//  Method: avtQDFFileFormat::findSubPopSubGroups
//
//  Purpose:
//      Finds the population subgroups in the QDF file
//
//  HDF Group structure
//  "Population"      : <pop_name>* | <attributes>
//  pop_name          : <action_name>* | <data_set>
//  action_name       : <attributes>* | "SubPopulations" 
//  "SubPopulations"  : <sub_pop_name>*
//  sub_pop_name      : <data_set>
//
//  If an action has an ID attribute, this will be used to create a unique name
//  for the variables.
//
//  Programmer: jody
//  Creation:   Dec 2021
//  Modifications:
//
// ****************************************************************************

void avtQDFFileFormat::findSubPopSubGroups() {
    debug1 << "QDF: [findSubPopSubGroups] getting pop info in intialize... " << endl; debug1.flush();
                    
    int iResult = 0;
    int iGlobActionCount = 0;

    stringvec vPopNames;
    collectSubGroups(m_hPopGroup, vPopNames);

    
    // we know "Populations" only has population groups, no datasets
    
    m_vSubPopNames.clear();
    m_mSubPopNamesFull.clear();
    // loop through the real populations
    debug1 << "QDF: [findSubPopSubGroups] Creating metadata for " << vPopNames.size() << " populations" << endl; debug1.flush();
        
    for (uint idxPop = 0; idxPop < vPopNames.size(); idxPop++) {
        std::string sCurPopName = vPopNames[idxPop];
        printf("QDF: [findSubPopSubGroups] sCurName is now [%s]\n", sCurPopName.c_str());fflush(stdout);

        debug1 << "QDF: [findSubPopSubGroups] Pop #" << idxPop << "::: " << sCurPopName << endl; debug1.flush();
        printf("QDF: [findSubPopSubGroups] about to open pop group [%s]\n",  sCurPopName.c_str()); fflush(stdout);
        hid_t hThisPop = qdf_openGroup(m_hPopGroup, sCurPopName.c_str(), true);
        printf("QDF: [findSubPopSubGroups] hThisPop is %lx\n",  hThisPop); fflush(stdout);
        debug1 << "QDF: [findSubPopSubGroups] hThisPop is "<< hThisPop << endl; debug1.flush();
        
        // loop through action groups
        stringvec vActionNames;
        collectSubGroups(hThisPop, vActionNames);
        // here: loop through all actions
        for (unsigned idxAction = 0; idxAction < vActionNames.size(); idxAction++) {
            hid_t hAction = qdf_openGroup(hThisPop, vActionNames[idxAction].c_str());
            if (hAction != H5P_DEFAULT) {
                printf("QDF: [findSubPopSubGroups] hAction is %lx\n",  hAction); fflush(stdout);
                debug1 << "QDF: [findSubPopSubGroups] hAction is "<< hAction << endl; debug1.flush();


                    
                // 
                printf("QDF: [findSubPopSubGroups] about to query existence of [AgentBinSplitter] in [%s/%s]\n", m_vPopNames[idxPop].c_str(), vActionNames[idxAction].c_str()); fflush(stdout);
                
                printf("QDF: [findSubPopSubGroups] about to query existence of [%s] in hAction\n", SUBPOPGROUP_NAME); fflush(stdout);
                if (H5Lexists(hAction, SUBPOPGROUP_NAME , H5P_DEFAULT)) {

                    // this let's see if this action has an ID attribute
                    std::string sID = "";
                    printf("QDF: [findSubPopSubGroups] about to query attriute existence of [id] in hAction\n"); fflush(stdout);
                    hid_t hAttID = H5Aexists(hAction, "id");
                    if (hAttID != H5P_DEFAULT) {
                        iResult = qdf_extractSAttribute2(hAction, "id", sID);
                    }
                    // otherwise: default if 
                    if (sID.empty()) {
                        char sNumber[16];
                        sprintf(sNumber, "%03d", iGlobActionCount);
                        sID = std::string("action_") + sNumber;
                    }
                    printf("QDF: [findSubPopSubGroups] sID of action [%s]: [%s]\n", vActionNames[idxAction].c_str(), sID.c_str()); fflush(stdout);

                    printf("QDF: [findSubPopSubGroups] about to open the group [%s] in hABS\n", SUBPOPGROUP_NAME); fflush(stdout);
                    hid_t hSubPopsGroup = qdf_openGroup(hAction, SUBPOPGROUP_NAME);
                    printf("QDF: [findSubPopSubGroups] hSubPopsGroup is %lx\n",  hSubPopsGroup); fflush(stdout);
                    debug1 << "QDF: [findSubPopSubGroups] hSubPopsGroup is "<< hSubPopsGroup << endl; debug1.flush();
                    
                    collectSubGroups(hSubPopsGroup, m_vSubPopNames);
                    
                    // SubPopulations also ony has groups (and no datasets)
                    for (uint idxSubPop = 0; idxSubPop < m_vSubPopNames.size(); idxSubPop++) {
                        debug1 << "QDF: [findSubPopSubGroups] in inner loop for '" << m_vSubPopNames[idxSubPop] << "'"  << endl; debug1.flush();
                        printf("QDF: [findSubPopSubGroups] in inner loop for '%s'\n",  m_vSubPopNames[idxSubPop].c_str());  fflush(stdout);
                        printf("QDF: [findSubPopSubGroups] about to open group [%s] in %lx\n",   m_vSubPopNames[idxSubPop].c_str(), hSubPopsGroup);  fflush(stdout);
                        hid_t hSubPop = qdf_openGroup(hSubPopsGroup, m_vSubPopNames[idxSubPop].c_str());
                        if (hSubPop != H5P_DEFAULT) {
                            
                            printf("QDF: [findSubPopSubGroups] hSubPop is %lx\n",  hSubPop);  fflush(stdout);
                            debug1 << "QDF: [findSubPopSubGroups] hSubPop is "<< hSubPop << endl; debug1.flush();
                            std::string sCurFullSubName = vPopNames[idxPop] + SEP_CHAR + sID + SEP_CHAR + m_vSubPopNames[idxSubPop];
                            printf("QDF: [findSubPopSubGroups] m_mSubPopNamesFull[%s] is [%s]\n", vPopNames[idxPop], m_vSubPopNames[idxSubPop].c_str()); fflush(stdout);
                            m_mSubPopNamesFull[m_vSubPopNames[idxSubPop]] = sCurFullSubName;
                            printf("QDF: [findSubPopSubGroups] m_mSubPopNamesFull[%s] is [%s]\n", m_vSubPopNames[idxSubPop].c_str(), m_mSubPopNamesFull[m_vSubPopNames[idxSubPop]].c_str()); fflush(stdout);
                            printf("QDF: [findSubPopSubGroups] about to query existence of [%s] in hSubPop\n", AGENT_DATASET_NAME); fflush(stdout);
                            if (H5Lexists(hSubPop, AGENT_DATASET_NAME, H5P_DEFAULT))  {
                                m_mapAgentGroups[sCurFullSubName] = hSubPop;
                                printf("QDF: [findSubPopSubGroups] m_mapAgentGroups['%s'] is %lx\n", sCurFullSubName.c_str(),  m_mapAgentGroups[sCurFullSubName]); fflush(stdout);

                                // here: only extracz cellID?
                                printf("QDF: [findSubPopSubGroups] about to open the dataset [%s] in hSubPop\n", AGENT_DATASET_NAME); fflush(stdout);
                                hid_t hThisSubDataset = H5Dopen(hSubPop, AGENT_DATASET_NAME, H5P_DEFAULT);
                                printf("QDF: [findSubPopSubGroups] hThisSubDataset is %lx\n",  hThisSubDataset);  fflush(stdout);
                                hid_t hAgentType = H5Dget_type(hThisSubDataset);     // get the agent compound data type
                                int nFields = H5Tget_nmembers(hAgentType);        // how many data fiels are in the compound agent type?
                                size_t iAgentTypeSize = H5Tget_size(hAgentType);  // get its size in bytes for later use
                                hssize_t nAgents = H5Dget_storage_size(hThisSubDataset)/iAgentTypeSize; // how many agents?
                                
                                // save valuable information for later use
                                m_mapDataAgents.insert(std::pair<std::string,hid_t>(sCurFullSubName, hThisSubDataset));
                                m_mapNAgents.insert(std::pair<std::string, int>(sCurFullSubName, (int)nAgents));
                                debug1 << "QDF: [findSubPopSubGroups] added Pop data for '" << sCurFullSubName << ".(" << nAgents <<" agents) to  m_mapDataAgents and  m_mapNAgents" << endl; debug1.flush();
                                
                                
                                for (unsigned int k = 0; k < nFields; k++) {
                                    char* sFieldName = new char[63];
                                    sFieldName = H5Tget_member_name(hAgentType, k);  // get the name of each field
                                    int iFieldOffset = H5Tget_member_offset(hAgentType, k);   // get its offset for later use
                                    hid_t tFieldType = H5Tget_member_type(hAgentType, k);
                                    hid_t tFieldTypeSize = H5Tget_size(tFieldType);
                                    
                                    // create datatype for this data field, we need it to read the data
                                    // without having to fill in a whole agent array with everything
                                    hid_t tReadType = H5Tcreate(H5T_COMPOUND, tFieldTypeSize);
                                    H5Tinsert(tReadType, sFieldName, 0, tFieldType);
                                    
                                    /*
                                    char* sUniqueFieldName = new char[128];
                                    strcpy(sUniqueFieldName, sCurFullSubName.c_str());
                                    
                                    strcat(sUniqueFieldName, SEP_CHAR);
                                    strcat(sUniqueFieldName, sFieldName);  // name = POPNAME:FIELDNAME to avoid duplication between pops
                                    */
                                    debug1 << "QDF: [findSubPopSubGroups] adding metadata for " << sUniqueFieldName << endl; debug1.flush();
                                        
                                    group_type pairDatasetAndType = group_type(hThisSubDataset, tReadType);
                                    name_group pairNames = name_group(sCurPopName, pairDatasetAndType);  // is sCurPopName  the right one?
                                    m_mapAgentFields.insert(std::pair<std::string,name_group>(sCurFullSubName, pairNames)); 
                                    delete sFieldName;
                                } // end for k
                                
                            } else {
                                    debug1 << "QDF: [findSubPopSubGroups] no dataset [" << AGENT_DATASET_NAME << "] found in [" <<  m_vSubPopNames[idxSubPop] << "]" << endl; debug1.flush();
                            }
                            //qdf_closeGroup(hSubPop);
                            // this group mist be closed
                        } else {
                            debug1 << "QDF: [findSubPopSubGroups] couldn't open subpop group [" << m_vSubPopNames[idxSubPop] << "] in [" <<  "Populations/" << vPopNames[idxPop] << "]" << endl; debug1.flush();
                        }
                    } // end for idxSubPopj    
                        qdf_closeGroup(hSubPopsGroup);
                } else {
                    debug1 << "QDF: [findSubPopSubGroups] no subgroup [" << SUBPOPGROUP_NAME << "] found in [" <<  sCurPopName << "]" << endl; debug1.flush();
                }
                qdf_closeGroup(hAction);
            } else {
                debug1 << "QDF: [findSubPopSubGroups] no subgroup [" << vActionNames[idxAction] << "] found in [" <<  "Populations" << "]" << endl; debug1.flush();
            }
        } // end for idxAction
    } // end for idxPop
    printf("QDF: [findSubPopSubGroups] leaving method\n");   fflush(stdout);

    printf("QDF: [findSubPopSubGroups] m_vSubPopNames & Co\n"); fflush(stdout);
    for (uint i = 0; i < m_vSubPopNames.size(); i++) {
        printf(" popn [%s] => full[%s] => hpop[%lx]\n",  m_vSubPopNames[i].c_str(), m_mSubPopNamesFull[m_vSubPopNames[i]].c_str(),  m_mapAgentGroups[m_mSubPopNamesFull[m_vSubPopNames[i]]]); fflush(stdout);
    }

    debug1 << "QDF: [findSubPopSubGroups] leaving method" << endl;   debug1.flush();
}

// ****************************************************************************
//  Method: avtQDFFileFormat::findPieSubGroups
//
//  Purpose:
//      Finds the pieplot subgroups in the QDF file
//
//  Programmer: jody
//  Creation:   Dec 2021
//  Modifications:
//// ****************************************************************************
void
avtQDFFileFormat::findPieSubGroups() {
    debug1 << "QDF: [findPieSubGroups] getting pie info in intialize... " << endl; debug1.flush();
    H5G_info_t infoPieGroup;
    int iResult = H5Gget_info(m_hPieGroup, &infoPieGroup);
    
    if (iResult >= 0) {
        int nPies = infoPieGroup.nlinks;
        debug1 << "QDF: [findPieSubGroups] collecting data for " << nPies << " pie plots" << endl; debug1.flush();
                        
        if (m_vPieNames.size() != 0) {
            m_vPieNames.clear();
        }
        m_mapPieSubGroups.clear();
        
        debug1 << "QDF: [findPieSubGroups] collecting data for " << nPies << " pie plots" << endl << std::flush;
        for (int i = 0; i < nPies; i++) {
            char sTempName[1024];
            H5Gget_objname_by_idx(m_hPieGroup, i, sTempName, 1023);
            m_vPieNames.push_back(sTempName);
            
            debug1 << "QDF: [findPieSubGroups]   Pie #" << i << "::: " << sTempName << endl;  debug1.flush();
            
            hid_t hThisPie = qdf_openGroup(m_hPieGroup, m_vPieNames[i].c_str(), true);
                            
            if (H5Lexists(hThisPie, PIE_DATASET_NAME, H5P_DEFAULT)) {
                // save valuable information for later use
                m_mapPieSubGroups.insert(std::pair<std::string,hid_t>(sTempName, hThisPie));
                debug1 << "QDF: [findPieSubGroups]   added Pie data for '" << sTempName << " to  m_mapPieDatasetss" << endl << std::flush;
                
            } else {
                debug1 << "QDF: [findPieSubGroups]   group [" << sTempName << "] has no data set [" << PIE_DATASET_NAME << "]" << endl << std::flush;
            } 
                            
        }

        debug1 << "QDF: [findPieSubGroups] data collected " << nPies << " pie plots" << endl << std::flush;
    } else {
        debug1 << "QDF: [findPieSubGroups] couldn't find info for piegroup" << endl << std::flush;
    }
}


// ****************************************************************************
//  Method: avtQDFFileFormat::findVecSubGroups
//
//  Purpose:
//      Finds the vector data subgroups in the QDF file
//
//  Programmer: jody
//  Creation:   Dec 2021
//  Modifications:
//
// ****************************************************************************
void
avtQDFFileFormat::findVecSubGroups() {
    debug1 << "QDF: [findVecSubGroups] getting vec info in intialize... " << endl; debug1.flush();
    debug1 << "QDF: [findVecSubGroups] m_hVecGroup is (" << m_hVecGroup << ") in " << this << endl; debug1.flush();

    H5G_info_t infoVecGroup;
    int iResult = H5Gget_info(m_hVecGroup, &infoVecGroup);
    
    if (iResult >= 0) {
        int nVecs = infoVecGroup.nlinks;
        debug1 << "QDF: [findVecSubGroups] collecting data for " << nVecs << " vector data groups" << endl; debug1.flush();
                        
        if (m_vVecNames.size() != 0) {
            m_vVecNames.clear();
        }
        m_mapVecSubGroups.clear();
        
        debug1 << "QDF: [findVecSubGroups] collecting data for " << nVecs << " vector data groups" << endl << std::flush;

        for (int i = 0; i < nVecs; i++) {
            char sTempName[1024];
            H5Gget_objname_by_idx(m_hVecGroup, i, sTempName, 1023);
            m_vVecNames.push_back(sTempName);
            
            debug1 << "QDF: [findVecSubGroups] Vec #" << i << "::: " << sTempName << endl;  debug1.flush();
            hid_t hThisVec = qdf_openGroup(m_hVecGroup, m_vVecNames[i].c_str(), true);
                            
            if (H5Lexists(hThisVec, VEC_DATASET_NAME, H5P_DEFAULT)) {
                // save valuable information for later use
                m_mapVecSubGroups.insert(std::pair<std::string,hid_t>(sTempName, hThisVec));
                debug1 << "QDF: [findVecSubGroups] added Vector data for '" << sTempName << " to  m_mapVecDatasetss" << endl << std::flush;
                
            } else {
                debug1 << "QDF: [findVecSubGroups] group [" << sTempName << "] has no data set [" << VEC_DATASET_NAME << "]" << endl << std::flush;
            } 
                            
        }

        debug1 << "QDF: [findVecSubGroups] data collected " << nVecs << " vec plots" << endl << std::flush;
    } else {
        debug1 << "QDF: [findVecSubGroups] couldn't find info for vecgroup (" << m_hVecGroup << ")" << endl << std::flush;
    }
}




// ****************************************************************************
//  Method: avtQDFFileFormat::Initialize
//
//  Purpose:
//      Finds the pieplot subgroups in the QDF file
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::Initialize() {
    if(!m_initialized) {
        //        m_hFile = qdf_openFile(m_sFileName);
        debug1 << "QDF: [Initialize] (this:" << this << ")file: " << m_sFileName << endl;
        if (m_hFile == H5P_DEFAULT) {
            m_hFile = H5Fopen(m_sFileName, H5F_ACC_RDONLY, H5P_DEFAULT);
            if (m_hFile != H5P_DEFAULT) {
                debug1 << "QDF: [Initialize] got file: " << m_hFile << endl;
                if (m_hGridGroup == H5P_DEFAULT) {
                    m_hGridGroup = qdf_openGroup(m_hFile, GRIDGROUP_NAME, true);
                }
        
                if (m_hGridGroup != H5P_DEFAULT) {
                    debug1 << "QDF: [Initialize] got grid: " << m_hGridGroup << endl;
                    int iRes = qdf_extractSAttribute(m_hGridGroup, "SURF_TYPE", 62, m_sGridType); // LTC, ICO, IEQ
                    if (iRes != 0) {
                        qdf_extractSAttribute(m_hGridGroup, "SURFTYPE", 62, m_sGridType); // because we like to change stuff at random
                    }
                    if (iRes == 0) {
                        // open all top-level groups

                        debug1 << "QDF: [Initialize] checking geo" << endl;
                        if ((m_hGeoGroup == H5P_DEFAULT)  && (H5Lexists(m_hFile, GEOGROUP_NAME, H5P_DEFAULT))){
                            m_hGeoGroup = qdf_openGroup(m_hFile, GEOGROUP_NAME, true);
                            debug1 << "QDF: [Initialize] got geo: " << m_hGeoGroup << endl;
                        }

                        debug1 << "QDF: [Initialize] checking climate" << endl;
                        if ((m_hClimateGroup == H5P_DEFAULT) && (H5Lexists(m_hFile, CLIGROUP_NAME, H5P_DEFAULT))) {
                            m_hClimateGroup = qdf_openGroup(m_hFile, CLIGROUP_NAME, true);
                            debug1 << "QDF: [Initialize] got climate: " << m_hClimateGroup << endl;
                        }

                        debug1 << "QDF: [Initialize] checking vegetation" << endl;
                        if ((m_hVegGroup == H5P_DEFAULT) && (H5Lexists(m_hFile, VEGGROUP_NAME, H5P_DEFAULT))) {
                            m_hVegGroup     = qdf_openGroup(m_hFile, VEGGROUP_NAME, true);
                            debug1 << "QDF: [Initialize] got vegtation: " << m_hVegGroup << endl;
                        }

                        debug1 << "QDF: [Initialize] checking navigation" << endl;
                        if ((m_hNavGroup == H5P_DEFAULT) && (H5Lexists(m_hFile, NAVGROUP_NAME, H5P_DEFAULT))) {
                            m_hNavGroup      = qdf_openGroup(m_hFile, NAVGROUP_NAME, false);
                            debug1 << "QDF: [Initialize] got navigation: " << m_hNavGroup << endl;
                        }

                        debug1 << "QDF: [Initialize] checking pops" << endl;debug1.flush();
                        if ((m_hPopGroup == H5P_DEFAULT) && (H5Lexists(m_hFile, POPGROUP_NAME, H5P_DEFAULT))) {
                            m_hPopGroup = qdf_openGroup(m_hFile, POPGROUP_NAME, true);
                            debug1 << "QDF: [Initialize] got pops: " << m_hPopGroup << endl;debug1.flush();
                        }

                        debug1 << "QDF: [Initialize] checking pies" << endl;debug1.flush();
                        if ((m_hPieGroup == H5P_DEFAULT) && (H5Lexists(m_hFile, PIEGROUP_NAME, H5P_DEFAULT))) {
                            m_hPieGroup = qdf_openGroup(m_hFile, PIEGROUP_NAME, true);
                            debug1 << "QDF: [Initialize] got pies: " << m_hPieGroup << endl;debug1.flush();
                        }

                    } else {
                        debug1 << "QDF: [Initialize] couldnt determine surface type" << endl;
                    }
                } else {
                    debug1 << "QDF: [Initialize] Group " << GRIDGROUP_NAME << " not found!!!" << endl;
                }

                

                // find groups for populations
                if (m_hPopGroup != H5P_DEFAULT) {
                    findPopSubGroups();
                } else {
                    debug1 << "QDF: [Initialize] no pop group" << endl;
                }
                
                // find subgroups for populations
                if (m_hPopGroup != H5P_DEFAULT) {
                    findSubPopSubGroups();
                } else {
                    debug1 << "QDF: [Initialize] no pop group" << endl;
                }
                

                // find groups for pieplots
                if (m_hPieGroup != H5P_DEFAULT) {
                    findPieSubGroups();
                } else {
                    debug1 << "QDF: [Initialize] no pie group" << endl;
                }        
                
                // find groups for vector plots
                if (m_hVecGroup != H5P_DEFAULT) {
                    findVecSubGroups();
                } else {
                    debug1 << "QDF: [Initialize] no vec group" << endl;
                }        
                
                m_initialized = true;
            } else {
                debug1 << "QDF: [Initialize] couldn't open file '" << m_sFileName << "'" << endl; debug1.flush();
            }
        } else {
            debug1 << "QDF: [Initialize] file already open"  << endl << std::flush;
        }
    } else {
        debug1 << "QDF: [Initialize] already initialized"  << endl << std::flush;
    }
    debug1 << "QDF: [Initialize] exiting now+" << std::endl << std::flush;
}



// ****************************************************************************
//  Method: avtQDFFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

void
avtQDFFileFormat::FreeUpResources(void)
{
    // i'm not sure what we can remove...
    /*
    if (m_hGridGroup >= 0) {
        qdf_closeGroup(m_hGridGroup);
        m_hGridGroup = H5P_DEFAULT;
    }

    if (m_hGeoGroup > 0) {
        qdf_closeGroup(m_hGeoGroup);
        m_hGeoGroup = H5P_DEFAULT;
     }

    if (m_hClimateGroup > 0) {
        qdf_closeGroup(m_hClimateGroup);
        m_hClimateGroup = H5P_DEFAULT;
    }

    if (m_hVegGroup > 0) {
        qdf_closeGroup(m_hVegGroup);
        m_hVegGroup = H5P_DEFAULT;
    }

    if (m_hPopGroup > 0) {

        for (std::map<std::string,hid_t>::iterator it = m_mapDataAgents.begin(); 
             it != m_mapDataAgents.end(); 
             it++) {
            qdf_closeDataSet(it->second);
        }

        m_mapNAgents.clear();
        m_mapDataAgents.clear();


        qdf_closeGroup(m_hPopGroup);
        m_hPopGroup = H5P_DEFAULT;
    }

    if (m_hFile > 0) {
        H5Fclose(m_hFile);
        m_hFile = H5P_DEFAULT;
    }

    m_initialized = false;
    
    memset(m_sGridType, 0, 64);
    */
}


// ****************************************************************************
//  Method: avtQDFFileFormat::createGridMetaData
//
//  Purpose:
//      Creates the meta data for the grid
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createGridMetaData(avtDatabaseMetaData *md) {
    if (m_hGridGroup != H5P_DEFAULT) {

        debug1 << "QDF: [createGridMetaData] surface type: " << m_sGridType << endl;
        
        avtMeshMetaData *MeshMD = new avtMeshMetaData;
        
        MeshMD->name = GRIDGROUP_NAME;
        
        if (strcasecmp(m_sGridType, "LTC") == 0) {
            
            char* sLinks = new char[4];
            qdf_extractSAttribute(m_hGridGroup, "LINKS", 4, sLinks); 
            int iLinks = atoi(sLinks);
            delete[] sLinks;
            
            if (iLinks == 4) {
                debug1 << "QDF: [createGridMetaData] metadata: rectangular mesh" << endl;
                MeshMD->meshType = AVT_RECTILINEAR_MESH;
            } else if (iLinks == 6) {
                debug1 << "QDF: [createGridMetaData] metadata: hexagonal mesh" << endl;
                MeshMD->meshType = AVT_UNSTRUCTURED_MESH;
            }
            MeshMD->spatialDimension = 2;
            
        } else {
            //            MeshMD->meshType = AVT_UNSTRUCTURED_MESH; 
            debug1 << "QDF: [createGridMetaData] metadata: icosahedral mesh" << endl;
            MeshMD->meshType = AVT_UNSTRUCTURED_MESH;
            MeshMD->spatialDimension = 3;
        }
        
        MeshMD->topologicalDimension = 2; 
        MeshMD->numBlocks = 1;
        
        md->Add(MeshMD);
    } else {
      debug1 << "QDF: [createGridMetaData] metadata: there's no grid in " << m_sFileName << endl;
        // WE DON'T HAVE FRID
    }
}


// ****************************************************************************
//  Method: avtQDFFileFormat::createGeographyMetaData
//
//  Purpose:
//      Creates the meta data for the geography group:
//      - Longitude
//      - Latitude
//      - Altitude
//      - Area
//      - Water
//      - Ice
//      - Coastal
//      - Angles
//      
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createGeographyMetaData(avtDatabaseMetaData *md) {
    if (m_hGeoGroup != H5P_DEFAULT) {
        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_LONGITUDE <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_LONGITUDE, H5P_DEFAULT)) {
            avtScalarMetaData *LongitudeMD = new avtScalarMetaData;
            LongitudeMD->name = GEO_DS_LONGITUDE;
            LongitudeMD->meshName = GRIDGROUP_NAME;
            LongitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            LongitudeMD->hasUnits = true;
            LongitudeMD->units = "degrees";
            md->Add(LongitudeMD);
        }

        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_LATITUDE <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_LATITUDE, H5P_DEFAULT)) {
            avtScalarMetaData *LatitudeMD = new avtScalarMetaData;
            LatitudeMD->name = GEO_DS_LATITUDE;
            LatitudeMD->meshName = GRIDGROUP_NAME;
            LatitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            LatitudeMD->hasUnits = true;
            LatitudeMD->units = "degrees";
            md->Add(LatitudeMD);
        }

        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_ALTITUDE <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_ALTITUDE, H5P_DEFAULT)) {
            avtScalarMetaData *AltitudeMD = new avtScalarMetaData;
            AltitudeMD->name = GEO_DS_ALTITUDE;
            AltitudeMD->meshName = GRIDGROUP_NAME;
            AltitudeMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            AltitudeMD->hasUnits = true;
            AltitudeMD->units = "meters";
            md->Add(AltitudeMD);
        }

        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_AREA <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_AREA, H5P_DEFAULT)) {
            avtScalarMetaData *AreaMD = new avtScalarMetaData;
            AreaMD->name = GEO_DS_AREA;
            AreaMD->meshName = GRIDGROUP_NAME;
            AreaMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            AreaMD->hasUnits = true;
            AreaMD->units = "Earth radii squared";
            md->Add(AreaMD);
        }
        
        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_WATER <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_WATER, H5P_DEFAULT)) {
            avtScalarMetaData *WaterMD = new avtScalarMetaData;
            WaterMD->name = GEO_DS_WATER;
            WaterMD->meshName = GRIDGROUP_NAME;
            WaterMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            WaterMD->hasUnits = true;
            WaterMD->units = "";
            md->Add(WaterMD);
        }
        
        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_ICE_COVER <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_ICE_COVER, H5P_DEFAULT)) {
            avtScalarMetaData *IceMD = new avtScalarMetaData;
            IceMD->name = GEO_DS_ICE_COVER;
            IceMD->meshName = GRIDGROUP_NAME;
            IceMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            IceMD->hasUnits = false;
            md->Add(IceMD);
        }
        
        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_COASTAL <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_COASTAL, H5P_DEFAULT)) {
            avtScalarMetaData *CoastalMD = new avtScalarMetaData;
            CoastalMD->name = GEO_DS_COASTAL;
            CoastalMD->meshName = GRIDGROUP_NAME;
            CoastalMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            CoastalMD->hasUnits = false;
            md->Add(CoastalMD);
        }

        debug1 << "QDF: [createGeographyMetaData] metadata: doing geo group H5Lexists(" << m_hGeoGroup<<", "<< GEO_DS_ANGLES <<")" << endl << std::flush;
        if (H5Lexists(m_hGeoGroup, GEO_DS_ANGLES, H5P_DEFAULT)) {
            for (int i = 0; i < 6; i++) {
                char sName[128];
                sprintf(sName, "%s_%d", GEO_DS_ANGLES, i);
                avtScalarMetaData *AnglesMD = new avtScalarMetaData;
                AnglesMD->name = sName;
                AnglesMD->meshName = GRIDGROUP_NAME;
                AnglesMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                AnglesMD->hasUnits = false;
                md->Add(AnglesMD);
            }
        }

        
    } else {
        debug1 << "QDF: [createGeographyMetaData] metadata: there's no geography in " << m_sFileName << endl;
        // WE DON'T HAVE GEOGRAPHY
    }

}

// ****************************************************************************
//  Method: avtQDFFileFormat::createClimateMetaData
//
//  Purpose:
//      Creates the meta data for the climate group:
//      - ActTemp
//      - ActRain
//      - AnnMeanTemp
//      - AnnTotRain
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createClimateMetaData(avtDatabaseMetaData *md) {
    if (m_hClimateGroup != H5P_DEFAULT) {
        debug1 << "QDF: [createClimateMetaData] metadata: doing climate group" << endl;
        
        debug1 << "QDF: [createClimateMetaData] metadata: doing cliamte group H5Lexists(" << m_hClimateGroup <<", "<< CLI_DS_ACTUAL_TEMPS <<")" << endl << std::flush;
        if (H5Lexists(m_hClimateGroup, CLI_DS_ACTUAL_TEMPS, H5P_DEFAULT)) {
            avtScalarMetaData *ActTempMD = new avtScalarMetaData;
            ActTempMD->name = CLI_DS_ACTUAL_TEMPS;
            ActTempMD->meshName = GRIDGROUP_NAME;
            ActTempMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            ActTempMD->hasUnits = true;
            ActTempMD->units = "Celsius";
            md->Add(ActTempMD);
        }
        
        debug1 << "QDF: [createClimateMetaData] metadata: doing cliamte group H5Lexists(" << m_hClimateGroup <<", "<< CLI_DS_ACTUAL_RAINS <<")" << endl << std::flush;
        if (H5Lexists(m_hClimateGroup, CLI_DS_ACTUAL_RAINS, H5P_DEFAULT)) {
            avtScalarMetaData *ActRainMD = new avtScalarMetaData;
            ActRainMD->name = CLI_DS_ACTUAL_RAINS;
            ActRainMD->meshName = GRIDGROUP_NAME;
            ActRainMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            ActRainMD->hasUnits = true;
            ActRainMD->units = "";
            md->Add(ActRainMD);
        }
        
        debug1 << "QDF: [PopulateDatabaseMetaData] metadata: doing cliamte group H5Lexists(" << m_hClimateGroup <<", "<< CLI_DS_ANN_MEAN_TEMP <<")" << endl << std::flush;
        if (H5Lexists(m_hClimateGroup, CLI_DS_ANN_MEAN_TEMP, H5P_DEFAULT)) {
            avtScalarMetaData *AnnMeanTempMD = new avtScalarMetaData;
            AnnMeanTempMD->name = CLI_DS_ANN_MEAN_TEMP;
            AnnMeanTempMD->meshName = GRIDGROUP_NAME;
            AnnMeanTempMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            AnnMeanTempMD->hasUnits = true;
            AnnMeanTempMD->units = "Celsius";
            md->Add(AnnMeanTempMD);
        }
        
        debug1 << "QDF: [PopulateDatabaseMetaData] metadata: doing cliamte group H5Lexists(" << m_hClimateGroup <<", "<< CLI_DS_ANN_TOT_RAIN <<")" << endl << std::flush;
        if (H5Lexists(m_hClimateGroup, CLI_DS_ANN_TOT_RAIN, H5P_DEFAULT)) {
            avtScalarMetaData *AnnTotRainMD = new avtScalarMetaData;
            AnnTotRainMD->name = CLI_DS_ANN_TOT_RAIN;
            AnnTotRainMD->meshName = GRIDGROUP_NAME;
            AnnTotRainMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
            AnnTotRainMD->hasUnits = true;
            AnnTotRainMD->units = "";
            md->Add(AnnTotRainMD);
        }

        // seasonal data is a bit tougher, maybe do it later

    } else {
        debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no climate in " << m_sFileName << endl;
        // WE DON'T HAVE CLIMATE
    }

}


// ****************************************************************************
//  Method: avtQDFFileFormat::createVegetationMetaData
//
//  Purpose:
//      Creates the meta data for the climate group:
//      - VegBaseANPP
//      - VegANPP
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createVegetationMetaData(avtDatabaseMetaData *md) {
    if (m_hVegGroup != H5P_DEFAULT) {
            
        qdf_extractAttribute(m_hVegGroup, VEG_ATTR_NUM_SPECIES, 1, &m_nVegSpecies);
        debug1 << "QDF: [createVegetationMetaData] metadata: doing veg group" << endl;
            
        if (H5Lexists(m_hVegGroup, VEG_DS_BASE_NPP, H5P_DEFAULT)) {
            debug1 << "QDF: [createVegetationMetaData] metadata: have base npp" << endl;
            
            avtScalarMetaData *VegBaseANPPMD = new avtScalarMetaData;
            VegBaseANPPMD->name = VEG_DS_BASE_NPP;
            VegBaseANPPMD->meshName = GRIDGROUP_NAME;
            VegBaseANPPMD->centering = AVT_NODECENT;
            VegBaseANPPMD->hasUnits = true;
            VegBaseANPPMD->units = "unknown";
            md->Add(VegBaseANPPMD);
            
        }
            

        if (H5Lexists(m_hVegGroup, VEG_DS_NPP, H5P_DEFAULT)) {
            debug1 << "QDF: [createVegetationMetaData] metadata: have npp" << endl;
            
            avtScalarMetaData *VegANPPMD = new avtScalarMetaData;
            VegANPPMD->name = VEG_DS_NPP;
            VegANPPMD->meshName = GRIDGROUP_NAME;
            VegANPPMD->centering = AVT_NODECENT;
            VegANPPMD->hasUnits = true;
            VegANPPMD->units = "unknown";
            md->Add(VegANPPMD);
            
        }
    } else {
        debug1 << "QDF: [createVegetationMetaData] metadata: there's no vegetation in " << m_sFileName << endl;
        // WE DON'T HAVE VEGETATION
    }
        
}


// ****************************************************************************
//  Method: avtQDFFileFormat::createNavigationMetaData
//
//  Purpose:
//      Creates the meta data for the climate group:
//      - NavMesh
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createNavigationMetaData(avtDatabaseMetaData *md) {
    if (m_hNavGroup != H5P_DEFAULT) {
      
        debug1 << "QDF: [createNavigationMetaData] metadata: have navigation" << endl;
                
        avtMeshMetaData *NavMeshMD = new avtMeshMetaData;
        
        NavMeshMD->name = NAVGROUP_NAME;
        NavMeshMD->meshType = AVT_UNSTRUCTURED_MESH;
        NavMeshMD->spatialDimension = 3;
        NavMeshMD->topologicalDimension = 1; 
        NavMeshMD->numBlocks = 1;
        md->Add(NavMeshMD);
        
    } else {
        debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no navigation in " << m_sFileName << endl;
        // we don't have navigation
    }
}



// ****************************************************************************
//  Method: avtQDFFileFormat::createPopulationMetaData
//
//  Purpose:
//      Creates the meta data for the population groups
//      - PopMesh (individual agents)
//      - PopDens
//      - PopCap
//      - PopArr
//      - PopDist
//      - PopHops
//      - PopHybr
//      - all fields of the agents
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createPopulationMetaData(avtDatabaseMetaData *md) {
    if (m_hPopGroup != H5P_DEFAULT) {
            
        debug1 << "QDF: [createPopulationMetaData] (this:" << this <<") getting pop info... " << endl;

        int iResult = H5Gget_info(m_hPopGroup, &m_infoPopGroup);
            
        if (iResult >= 0) {
            m_nPops = m_infoPopGroup.nlinks;
            debug1 << "QDF: [createPopulationMetaData] Creating metadata for " << m_nPops << " populations" << endl << std::flush;
                
            for (int i = 0; i < m_nPops; i++) {

                debug1 << "QDF: [createPopulationMetaData] Pop #" << i << "::: " << m_vPopNames[i] << endl << std::flush;
                    
                hid_t hThisPop = qdf_openGroup(m_hPopGroup, m_vPopNames[i].c_str(), true);
                
                // first handle the agent data set (grid & number)
                debug1 << "QDF: [PopulateDatabaseMetaData] metadata: doing pop group [" << m_vPopNames[i] << "] H5Lexists(" << hThisPop <<", "<< AGENT_DATASET_NAME <<")" << endl << std::flush;
                if (H5Lexists(hThisPop, AGENT_DATASET_NAME, H5P_DEFAULT)) {

                    // create point mesh for population agents
                    avtMeshMetaData *PopMeshMD = new avtMeshMetaData;
                    PopMeshMD->name = m_vPopNames[i];
                    PopMeshMD->meshType = AVT_POINT_MESH;
                    PopMeshMD->spatialDimension = (!strcasecmp(m_sGridType,"LTC")) ? 2 : 3;
                    PopMeshMD->topologicalDimension = 0; 
                    PopMeshMD->numBlocks = 1;
                    md->Add(PopMeshMD);
                    debug1 << "QDF: [createPopulationMetaData] added point mesh for pop " << m_vPopNames[i] << endl << std::flush;

                    // add scalar for agent density by default to Grid mesh
                    // if there are agents this can always be done
                    std::string sPopDens =  m_vPopNames[i] + SEP_CHAR + NUMBER_NAME;

                    avtScalarMetaData *PopDensMD = new avtScalarMetaData;
                    PopDensMD->name = sPopDens;
                    PopDensMD->meshName = GRIDGROUP_NAME;
                    PopDensMD->centering = AVT_NODECENT;
                    PopDensMD->hasUnits = false;
                    PopDensMD->units = "";
                    md->Add(PopDensMD);
                    debug1 << "QDF: [createPopulationMetaData] added [" << sPopDens  << "] to metadata " << endl << std::flush;
                }                                 

                // now look at all datasets directly inside the populatiuon group
                stringvec vDataSetNames;
                collectNumericDataSets(hThisPop, vDataSetNames);
                
                debug1 << "QDF: [createPopulationMetaData] metadata: found " << vDataSetNames.size() << " numeric data sets" << endl << std::flush;

                for (uint j = 0; j < vDataSetNames.size(); j++)  {

                    debug1 << "QDF: [createPopulationMetaData] metadata: doing data set " << vDataSetNames[j] << " in pop group " << m_vPopNames[i] << endl << std::flush;
                    std::string sPopDataSet =  m_vPopNames[i] + SEP_CHAR + vDataSetNames[j];
                    
                    avtScalarMetaData *PopDataSetMD = new avtScalarMetaData;
                    PopDataSetMD->name = sPopDataSet;
                    PopDataSetMD->meshName = GRIDGROUP_NAME;
                    PopDataSetMD->centering = AVT_NODECENT;
                    PopDataSetMD->hasUnits = false;
                    PopDataSetMD->units = "";
                    md->Add(PopDataSetMD);

                    debug1 << "QDF: [createPopulationMetaData] added [" << sPopDataSet  << "] to metadata " << endl << std::flush;
                    std::string sPath = /*m_vPopNames[i] + "/" +*/ vDataSetNames[j];
                    truename_group tg = truename_group(sPath, hThisPop);
                    m_mapSpecialAgentVars.insert(std::pair<std::string, truename_group>(sPopDataSet, tg));
                    debug1 << "QDF: [createPopulationMetaData] mapSpecialAgentVars[" << sPopDataSet << "] = (" << sPath <<", " << hThisPop << ")" << endl << std::flush;
                    
                }

                // now find subgroups of the population group
                debug1 << "QDF: [createPopulationMetaData] now looking at actions in " << m_vPopNames[i] << endl << std::flush;
                stringvec vActionNames;
                collectSubGroups(hThisPop, vActionNames);
                for (uint j = 0; j < vActionNames.size(); j++)  {
                    
                     hid_t hAction = qdf_openGroup(hThisPop, vActionNames[j].c_str(), true);

                     // now find datasets in subgroup
                     debug1 << "QDF: [createPopulationMetaData] now looking at datasets in " << vActionNames[j] << endl << std::flush;
                     stringvec vSubDataSetNames;
                     collectNumericDataSets(hAction, vSubDataSetNames);

                     debug1 << "QDF: [createPopulationMetaData] metadata: found " << vSubDataSetNames.size() << " numeric data sets in action group " << vActionNames[j]<< endl << std::flush;

                     for (uint k = 0; k < vSubDataSetNames.size(); k++)  {

                         debug1 << "QDF: [createPopulationMetaData] metadata: doing data set " << vSubDataSetNames[k] << " in action group " << m_vPopNames[i] << "/" << vActionNames[j] << endl << std::flush;
                         std::string sPopSubDataSet =  m_vPopNames[i] + SEP_CHAR + vActionNames[j] + vSubDataSetNames[k];
                    
                         avtScalarMetaData *PopSubDataSetMD = new avtScalarMetaData;
                         PopSubDataSetMD->name = sPopSubDataSet;
                         PopSubDataSetMD->meshName = GRIDGROUP_NAME;
                         PopSubDataSetMD->centering = AVT_NODECENT;
                         PopSubDataSetMD->hasUnits = false;
                         PopSubDataSetMD->units = "";
                         md->Add(PopSubDataSetMD);

                         std::string sPath =/* m_vPopNames[i] + "/" + vActionNames[j]+ "/" +*/ vSubDataSetNames[k];

                         truename_group tg = truename_group( vSubDataSetNames[k], hAction);
                         m_mapSpecialAgentVars.insert(std::pair<std::string, truename_group>(sPopSubDataSet, tg));
                         debug1 << "QDF: [createPopulationMetaData] mapSpecialAgentVars[" << sPopSubDataSet << "] = (" << sPath <<", " << hAction << ")" << endl << std::flush;
                         
                     }
                }
                
                    
                /*
                // add metadata for all agent fields
                std::map<std::string, name_group>::const_iterator ita;
                for (ita =  m_mapAgentFields.begin(); ita != m_mapAgentFields.end(); ++ita) {
                debug1 << "QDF: [createPopulationMetaData] adding metadata for " <<  ita->first << endl;
                avtScalarMetaData *ThisFieldMD = new avtScalarMetaData;
                ThisFieldMD->name = ita->first;
                ThisFieldMD->meshName = GRIDGROUP_NAME;
                ThisFieldMD->centering = AVT_NODECENT; // data is centered on nodes, not zones
                ThisFieldMD->hasUnits = false;
                md->Add(ThisFieldMD);
                debug1 << "QDF: added metadata" << endl;
                }
                */

            }
        } else {
            // WE DON'T HAVE POPULATIONS
            debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there are no populations in " << m_sFileName << endl;
        }
    }
}
// ****************************************************************************
//  Method: avtQDFFileFormat::createSubPopulationMetaData
//
//  Purpose:
//      Creates the meta data for the sub population groups
//      - PopMesh (individual agents)
//      - all fields of the agents
//
//  Programmer: jody
//  Creation:   Aug 2023
//  Modifications:
//       jody Aug 2923 added 
//
// ****************************************************************************
void
avtQDFFileFormat::createSubPopulationMetaData(avtDatabaseMetaData *md) {
    printf("QDF: [createSubPopulationMetaData] m_vSubPopNames & Co\n"); fflush(stdout);
    for (uint i = 0; i < m_vSubPopNames.size(); i++) {
        printf(" popn [%s] => full[%s] => hpop[%lx]\n",  m_vSubPopNames[i].c_str(), m_mSubPopNamesFull[m_vSubPopNames[i]].c_str(),  m_mapAgentGroups[m_mSubPopNamesFull[m_vSubPopNames[i]]]); fflush(stdout);
    }

    if (m_hPopGroup != H5P_DEFAULT) {
        printf("QDF: [createSubPopulationMetaData] this: %lx getting pop info...\n", this);
        debug1 << "QDF: [createSubPopulationMetaData] (this:" << this <<") getting pop info... " << endl;

        int iResult = H5Gget_info(m_hPopGroup, &m_infoPopGroup);
            
        debug1 << "QDF: [creatSubePopulationMetaData] Creating metadata for " << m_vSubPopNames.size() << " populations" << endl << std::flush;
        for (uint i = 0; i < m_vSubPopNames.size(); i++) {

            debug1 << "QDF: [createSubPopulationMetaData] Pop #" << i << "::: " << m_vSubPopNames[i] << endl << std::flush;
        
            // printf("QDF: [createSubPopulationMetaData] calling qdf_openGroup(%lx, %s, true)\n", m_mapAgentGroups[m_mSubPopNamesFull[m_vSubPopNames[i]]].c_str(), m_vSubPopNames[i].c_str()); fflush(stdout);
            hid_t hThisPop = m_mapAgentGroups[m_mSubPopNamesFull[m_vSubPopNames[i]]];
            debug1 << "QDF: [createSubPopulationMetaData] metadata: doing pop group [" << m_vSubPopNames[i] << "] H5Lexists(" << hThisPop <<", "<< m_vSubPopNames[i] <<")" << endl << std::flush;
            printf("QDF: [createSubPopulationMetaData] metadata: doing pop group [%s] H5Lexists(%lx, %s)\n",  m_vSubPopNames[i].c_str(), hThisPop,  AGENT_DATASET_NAME); fflush(stdout);
            if (H5Lexists(hThisPop, AGENT_DATASET_NAME, H5P_DEFAULT)) {
            
                // create point mesh for population agents
                avtMeshMetaData *PopMeshMD = new avtMeshMetaData;
                PopMeshMD->name = m_mSubPopNamesFull[m_vSubPopNames[i]];
                PopMeshMD->meshType = AVT_POINT_MESH;
                PopMeshMD->spatialDimension = (!strcasecmp(m_sGridType,"LTC")) ? 2 : 3;
                PopMeshMD->topologicalDimension = 0; 
                PopMeshMD->numBlocks = 1;
                md->Add(PopMeshMD);
                debug1 << "QDF: [createSubPopulationMetaData] added point mesh for pop " << m_vSubPopNames[i] << endl << std::flush;

                /* density: not for now
                // add scalar for agent density by default to Grid mesh
                // if there are agents this can always be done
                std::string sPopDens =  m_vPopNames[i] + SEP_CHAR + NUMBER_NAME;
                
                avtScalarMetaData *PopDensMD = new avtScalarMetaData;
                PopDensMD->name = sPopDens;
                PopDensMD->meshName = GRIDGROUP_NAME;
                PopDensMD->centering = AVT_NODECENT;
                PopDensMD->hasUnits = false;
                PopDensMD->units = "";
                md->Add(PopDensMD);
                debug1 << "QDF: [createSubPopulationMetaData] added [" << sPopDens  << "] to metadata " << endl << std::flush;
                */
            } else {
                // NO DATASET?
            }
        }
      
    } else {
        // WE DON'T HAVE POPULATIONS
        debug1 << "QDF: [createSubPopulationMetaData] metadata: there are no populations in " << m_sFileName << endl;
    }
    
}


// ****************************************************************************
//  Method: avtQDFFileFormat::createPieMetaData
//
//  Purpose:
//      Creates the meta data for the pieplot groups
//      - PieMesh (individual points)
//      - PieVec  ( the vector contiaining the data)
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createPieMetaData(avtDatabaseMetaData *md) {
    
    if (m_hPieGroup != H5P_DEFAULT) {
        
        debug1 << "QDF: [createPieMetaData] Creating metadata for " << m_vPieNames.size() << " pieplots" << endl;debug1.flush();
            
        for (int i = 0; i < m_vPieNames.size(); i++) {
                    
            debug1 << "QDF: [createPieMetaData] metadata: opening subgroup [" << m_vPieNames[i]<<"]  of pie group (" << m_hPieGroup <<")" << endl << std::flush;
            hid_t hThisPie = qdf_openGroup(m_hPieGroup, m_vPieNames[i].c_str(), true);

            debug1 << "QDF: [createPieMetaData] metadata: doing pie group H5Lexists(" << hThisPie <<", "<< PIE_DATASET_NAME <<")" << endl << std::flush;
            if (H5Lexists(hThisPie, PIE_DATASET_NAME, H5P_DEFAULT)) {
                int iNumDims = 0;
                int iResult = qdf_extractAttribute(hThisPie, PIE_ATTR_NUM_DIMS, 1, &iNumDims);
                
                if ((iResult != 0) || ((iNumDims != 2) && (iNumDims != 3))) {
                    debug1 << "QDF: [createPieMetaData] got bad value for dimensionality - using 3 dimensions" << endl << std::flush;
                    iNumDims = 3;
                } 
                std::string sMeshName = "_mesh";
                sMeshName = m_vPieNames[i] + sMeshName;
                // create point mesh for population agents
                
                avtMeshMetaData *PieMeshMD = new avtMeshMetaData;
                
                PieMeshMD->name = sMeshName;
                PieMeshMD->meshType = AVT_POINT_MESH;
                PieMeshMD->spatialDimension = iNumDims; // atually 3
                PieMeshMD->topologicalDimension = 0; 
                PieMeshMD->numBlocks = 1;
                PieMeshMD->hideFromGUI = true;
                md->Add(PieMeshMD);
                    
                debug1 << "QDF: [createPieMetaData] added point mesh for pie " << sMeshName << endl << std::flush;
                    
                debug1 << "QDF: [createPieMetaData] adding metadata for pie values [" << m_vPieNames[i] << "]" << endl;
                avtVectorMetaData *pPieVecMD = new avtVectorMetaData;
                pPieVecMD->name = m_vPieNames[i];
                pPieVecMD->meshName = sMeshName;
                pPieVecMD->centering = AVT_NODECENT;
                pPieVecMD->hasUnits = false;
                pPieVecMD->units = "";
                md->Add(pPieVecMD);
                    

                // we also have to create a label containing the value names
                std::string sNames = "";
                char sComponentNames[1024];
                std::vector<std::string> vParts;
                   
                iResult = qdf_extractSAttribute(hThisPie, PIE_ATTR_VAL_NAMES, 1024, sComponentNames);
                int iNumVals = 0;
                iResult = qdf_extractAttribute(hThisPie, PIE_ATTR_NUM_VALS, 1, &iNumVals);

                if (iResult == 0) {
                    debug1 << "QDF: [createPieMetaData] got val names string [" << sComponentNames <<"]" << endl <<std::flush;
                    // split the string and save in vec
                    char *p = strtok(sComponentNames, ";");
                    while (p != NULL) {
                        vParts.push_back(p);
                        p = strtok(NULL, ";");
                    }
                }
                else {
                    debug1 << "QDF: [createPieMetaData] couldn't extract number opf valus (attribute [" << PIE_ATTR_NUM_VALS <<"]" << endl <<std::flush;
                }

                // build string, first using the found components ...
                for (uint z = 0; z < vParts.size(); z++) {
                    if (z>0) {
                        sNames = sNames + ";";
                    }
                    sNames = sNames + vParts[z];
                }
                // ... then with dummy item names
                for (uint z = vParts.size(); z < iNumVals; z++) {
                    if (sNames != "") {
                        sNames = sNames + ";";
                    }
                    char st[64];
                    sprintf(st, "item_%03d", z);
                    sNames = sNames + st;
                }
 
                avtLabelMetaData *lmd = new avtLabelMetaData;
                lmd->name = std::string{"pieInfo_"} +  m_vPieNames[i];    
                debug1 << "QDF: [createPieMetaData] label meta data name [" << lmd->name << "]" << endl <<std::flush;
                debug1 << "QDF: [createPieMetaData] new label original name [" << sNames << "]" << endl <<std::flush;
                lmd->originalName = sNames.c_str();
                // Keep this info from being used elsewhere by VisIt
                lmd->validVariable = false;
                lmd->hideFromGUI = true;
                md->Add(lmd);
                debug1 << "QDF: [PopulateDatabaseMetaData] label meta data for [" << m_vPieNames[i] << "] done" << endl <<std::flush;
            
                
                //         debug1 << "QDF: [PopulateDatabaseMetaData] metadata for pieplots done " << endl << std::flush;
            }
        }
    } else {
        // we don't have pies
        debug1 << "QDF: [createPieMetaData] No pies found" << endl << std::flush;
    }
}


// ****************************************************************************
//  Method: avtQDFFileFormat::createVecMetaData
//
//  Purpose:
//      Creates the meta data for the pieplot groups
//      - PieMesh (individual points)
//      - PieVec  ( the vector contiaining the data)
//
//  Programmer: jody
//  Creation:   Apr 2019
//  Modifications:
//       jody Dec 2021 refactoring
//
// ****************************************************************************
void
avtQDFFileFormat::createVecMetaData(avtDatabaseMetaData *md) {
    debug1 << "QDF: [createVecMetaData] m_hVecGroup is (" << m_hVecGroup << ") in " << this << endl;

    if (m_hVecGroup != H5P_DEFAULT) {
       
        debug1 << "QDF: [createVecMetaData] Creating metadata for " << m_vVecNames.size() << " vector data" << endl;debug1.flush();
            
        for (int i = 0; i < m_vVecNames.size(); i++) {
                    
            debug1 << "QDF: [createVecMetaData] metadata: doing vec group H5Lexists (" << m_hVecGroup << ", " << m_vVecNames[i] << ")" << endl << std::flush;
            if (H5Lexists(m_hVecGroup, m_vVecNames[i].c_str(), H5P_DEFAULT)) {
                debug1 << "QDF: [createVecMetaData] metadata: opening subgroup [" << m_vVecNames[i]<<"]  of vec group (" << m_hVecGroup <<")" << endl << std::flush;
                hid_t hThisVec = qdf_openGroup(m_hVecGroup, m_vVecNames[i].c_str(), true);

                debug1 << "QDF: [createVecMetaData] metadata: doing vec group H5Lexists(" << hThisVec <<", "<< VEC_DATASET_NAME <<")" << endl << std::flush;
                if (H5Lexists(hThisVec, VEC_DATASET_NAME, H5P_DEFAULT)) {

                    std::string sMeshName = "_mesh";
                    sMeshName = m_vVecNames[i] + sMeshName;
                    // create point mesh for population agents
                    
                    avtMeshMetaData *VecMeshMD = new avtMeshMetaData;
                    
                    VecMeshMD->name = sMeshName;
                    VecMeshMD->meshType = AVT_POINT_MESH;
                    VecMeshMD->spatialDimension = 3;
                    VecMeshMD->topologicalDimension = 0; 
                    VecMeshMD->numBlocks = 1;
                    VecMeshMD->hideFromGUI = false;
                    md->Add(VecMeshMD);
                    
                    debug1 << "QDF: [createVecMetaData] added point mesh for pie " << sMeshName << endl << std::flush;
                    
                    debug1 << "QDF: [createVecMetaData] adding metadata for vec values [" << m_vVecNames[i] << "]" << endl;
                    avtVectorMetaData *pVecVecMD = new avtVectorMetaData;
                    pVecVecMD->name = m_vVecNames[i];
                    pVecVecMD->meshName = sMeshName;
                    pVecVecMD->centering = AVT_NODECENT;
                    pVecVecMD->hasUnits = false;
                    pVecVecMD->units = "";
                    md->Add(pVecVecMD);
                     
               
                    //         debug1 << "QDF: [PopulateDatabaseMetaData] metadata for pieplots done " << endl << std::flush;
                }
            } else {
                debug1 << "QDF: [createVecMetaData] metadata: no subgroup [" << m_vVecNames[i] << "] in vecgroup" << endl << std::flush;
            }
        }
    } else {
        // we don't have pies
        debug1 << "QDF: [createVecMetaData] No vectorgroup found" << endl << std::flush;
    }
}


// ****************************************************************************
//  Method: avtQDFFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//  Modifications:
//       jody Apr 2019   adapted  to QHG4 population format
//       jody Nov 2021   added Pie support
//       jody Dec 2021   refactoring (split up monlithic function into snaller ones
//
// ****************************************************************************

void
avtQDFFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    debug1 << "QDF: [PopulateDatabaseMetaData] populating metadata from file " << m_sFileName << endl;
    debug1 << "QDF: [PopulateDatabaseMetaData]  md is " << md << endl;
    //    Initialize();
     
    if (m_hGridGroup != H5P_DEFAULT) {
        createGridMetaData(md);

        // GEOGRAPHY
        if (m_hGeoGroup != H5P_DEFAULT) {
            createGeographyMetaData(md);
        } else {
            debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no geography in " << m_sFileName << endl;
           // WE DON'T HAVE GEOGRAPHY
        }


        // CLIMATE
        if (m_hClimateGroup != H5P_DEFAULT) {
            createClimateMetaData(md);
        } else {
            debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no climate in " << m_sFileName << endl;
            // WE DON'T HAVE CLIMATE
        }


        // VEGETATION
        if (m_hVegGroup != H5P_DEFAULT) {
            createVegetationMetaData(md);
        } else {
            debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no vegetation in " << m_sFileName << endl;
            // WE DON'T HAVE VEGETATION
        }
        


        // NAVIGATION
        if (m_hNavGroup != H5P_DEFAULT) {
            createNavigationMetaData(md);
        } else {
            debug1 << "QDF: [PopulateDatabaseMetaData] metadata: there's no navigation in " << m_sFileName << endl;
            // we don't have navigation
        }


        
        // POPULATIONS
        
        // here expose populations metadata
        // some of which will belong to the Pops point meshes
        // and some, e.g. density, will belong to the Grid mesh (GRIDGROUP_NAME)
        if (m_hPopGroup != H5P_DEFAULT) {
            createPopulationMetaData(md);
        } else {
            // WE DON'T HAVE POPULATIONS
        }

        if (m_hPopGroup != H5P_DEFAULT) {
            createSubPopulationMetaData(md);
        } else {
            // WE DON'T HAVE POPULATIONS
        }

        // PIEPLOTS
        
        // here expose pieplot metadata
        // there is one mesh per PiePlot, having a many ppooinbts as there are pies for this plot
        if (m_hPieGroup != H5P_DEFAULT) {
            createPieMetaData(md);
        } else {
            // we don't have pies
        }

        if (m_hVecGroup != H5P_DEFAULT) {
            //   createVecMetaData(md);
        } else {
            // WE DON'T HAVE POPULATIONS
        }

        
    } // end if (m_hGridGroup > 0)
    
    // should I delete the metadata here?
    debug1 << "QDF: [PopulateDatabaseMetaData] exiting " << endl << std::flush;
   
}


// ****************************************************************************
//  Method: avtQDFFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************


vtkDataSet *
avtQDFFileFormat::GetMesh(const char *meshname)
{
    debug1 << "QDF: [GetMesh] calld with meshname '"<< meshname << "'" << endl;
    debug1 << "QDF: [GetMesh] (after): " << m_sFileName << ": m_hFile is      " << m_hFile << endl;
    debug1 << "QDF: [GetMesh] (after): " << m_sFileName << ": m_hGridGroup is " << m_hGridGroup << endl;
    debug1 << "QDF: [GetMesh] (after): " << m_sFileName << ": m_hGeoGroup is  " << m_hGeoGroup << endl;
 
    vtkDataSet* NewMesh = NULL;

    if (strcasecmp(GRIDGROUP_NAME, meshname) == 0)  {
        // ----- grid mesh -------

        debug1 << "QDF: [GetMesh] for file " << m_sFileName << " (grid)" << endl;

                
        // we create a grid mesh

        //vtkDataSet* Grid = NULL;

        if (strcasecmp(m_sGridType, "LTC") == 0) {
 
            debug1 << "QDF: [GetMesh] it's a LTC " << endl;
 
            char* sLinks = new char[4];
            qdf_extractSAttribute(m_hGridGroup, "LINKS", 4, sLinks); 
            int iLinks = atoi(sLinks);
            delete[] sLinks;

            if (iLinks == 4) {
                NewMesh = GetRectMesh();
                debug1 << "QDF: [GetMesh] it's a 4-LTC (" << NewMesh << ")" << endl;

            } else if (iLinks == 6) {
                NewMesh = GetHexMesh();
                debug1 << "QDF: [GetMesh] it's a 6-LTC (" << NewMesh << ")" << endl;
            }

        } else if (strcasecmp(m_sGridType, "ICO") == 0 || 
                   strcasecmp(m_sGridType, "IEQ") == 0) {

            debug1 << "QDF: [GetMesh] it's a ICO or IEQ " << endl;
            
            if (m_hGeoGroup > 0) {
                char sSubDivs[64];
                qdf_extractSAttribute(m_hGridGroup, "SUBDIV", 63, sSubDivs);
                m_iSubDivs = atoi(sSubDivs);

                NewMesh = GetIcoEqMesh(); 
                debug1 << "QDF: [GetMesh] got ICO or IEQ grid (" << NewMesh << ")" << endl;
            } else {
                debug1 << "QDF: [GetMesh] ICO/IEQ has no GeoGroup" << endl;
            }      
        } else {
                debug1 << "QDF: [GetMesh] unknown grid type: " << m_sGridType << endl;
        }    
        //return Grid;

    } else if (strcasecmp(NAVGROUP_NAME, meshname) == 0) {
        // ----- navigation mesh -------
        debug1 << "QDF: [GetMesh] for file " << m_sFileName << "(nav)" << endl;

        // we create a grid mesh

        NewMesh = GetNavMesh();
        debug1 << "QDF: [GetMesh] it's a nav (" << NewMesh << ")" << endl;
       
    } else {
        if (strstr(meshname, "_mesh") == NULL) {
         
        
            // ----- agent meshes -------
            std::map<std::string, int>::const_iterator it;
            for (it = m_mapNAgents.begin(); it != m_mapNAgents.end(); ++it) {
                debug1 << "QDF: [GetMesh]   m_mapNAgents['"<< it->first << "'] = " << it->second << endl;
                
            }
            debug1 << "QDF: [GetMesh] checking if [" << meshname << "] is in m_mapNAgents" << endl;
            if (m_mapNAgents.find(meshname) != m_mapNAgents.end()) {
                debug1 << "QDF: [GetMesh]   found it!" << endl;
                if (strcasecmp(m_sGridType, "LTC") == 0) {
                    NewMesh = GetAgentFlatMesh(meshname);
                } else {
                    NewMesh = GetAgentIcoEqMesh(meshname);
                }
                debug1 << "QDF: [GetMesh] it's a pop (" << NewMesh << ")" << endl;
            } else {
                debug1 << "QDF: [GetMesh] CANNOT CREATE POP MESH " << meshname << endl;
                return NULL;
            }

        } else {
            NewMesh = GetPieMesh(meshname);
            if (NewMesh != NULL) {
                debug1 << "QDF: [GetMesh] it's a pie (" << NewMesh << ")" << endl;
            } else {
                    
                NewMesh = GetVecMesh(meshname);
                if (NewMesh != NULL) {
                    debug1 << "QDF: [GetMesh] it's a vec (" << NewMesh << ")" << endl;
                } else {
                }
           
           }

                //} else {
                // debug1 << "QDF: [GetMesh] CANNOT CREATE PIE MESH " << meshname << endl;
                //}
        }
    } 
/*
        // ----- agent meshes -------
        std::map<std::string, int>::const_iterator it;
        for (it = m_mapNAgents.begin(); it != m_mapNAgents.end(); ++it) {
            debug1 << "QDF: [GetMesh]   m_mapNAgents['"<< it->first << "'] = " << it->second << endl;
            
        }
        debug1 << "QDF: [GetMesh] checking if [" << meshname << "] is in m_mapNAgents" << endl;
        if (m_mapNAgents.find(meshname) != m_mapNAgents.end()) {
            debug1 << "QDF: [GetMesh]   found it!" << endl;
            //vtkDataSet *AgentMesh = NULL;
            if (strcasecmp(m_sGridType, "LTC") == 0) {
                NewMesh = GetAgentFlatMesh(meshname);
            } else {
                NewMesh = GetAgentIcoEqMesh(meshname);
            }
            //return AgentMesh;
            debug1 << "QDF: [GetMesh] it's a pop (" << NewMesh << ")" << endl;
        } else {
            debug1 << "QDF: [GetMesh] CANNOT CREATE MESH " << meshname << endl;
            return NULL;
        }
*/
    return NewMesh;
}


/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetAgentFlatMesh(const char *popname) {
    
    // for agent positions, we need to know spatial coordinates of grid nodes

    debug1 << "QDF: [GetAgentFlatMesh] called GetAgentFlatMesh" << endl;

    vtkDataSet *BaseGrid = GetMesh(GRIDGROUP_NAME);
    vtkIdType nNodes = BaseGrid->GetNumberOfPoints();

    debug1 << "QDF: [GetAgentFlatMesh] confirm that there are " << nNodes << " nodes" << endl;

    double *adNodes = (double*)malloc(nNodes * 3 * sizeof(double));
    for (vtkIdType i = 0; i < nNodes; i++) {
        BaseGrid->GetPoint(i, adNodes + 3 * i);
    }
    
    debug1 << "QDF: [GetAgentFlatMesh] got coordinates from " << GRIDGROUP_NAME << " for " << nNodes << " nodes" << endl;

    int nAgents = (m_mapNAgents.find(popname))->second;

    debug1 << "QDF: [GetAgentFlatMesh] processing data for " << nAgents << " agents" << endl;

    float *xarray = new float[nAgents];
    float *yarray = new float[nAgents];
    
    // let's read the agents' locations (cell IDs)

    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, SEP_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);
    hid_t hPopData = ((m_mapAgentFields.find(sCellIDName))->second).second.first;
    hid_t hCellIDType = ((m_mapAgentFields.find(sCellIDName))->second).second.second;
    
    debug1 << "QDF: [GetAgentFlatMesh] GetAgentFlatMesh preparing to read " << sCellIDName << endl;

    delete sCellIDName;

    int *aiAgentCells = new int[nAgents];

    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);
    
    srand(time(NULL));
    for (int i = 0; i < nAgents; i++) {
        int iCell = aiAgentCells[i];
        xarray[i] = (adNodes + 3 * iCell)[0] + 0.25 * m_fMinDistance * GeoDeviation();
        yarray[i] = (adNodes + 3 * iCell)[1] + 0.25 * m_fMinDistance * GeoDeviation();
    }
    
    debug1 << "QDF: [GetAgentFlatMesh] coords created" << endl;

    
    // now let's create the vtk points for the point mesh
    
    vtkPoints *Points = vtkPoints::New();
    Points->SetNumberOfPoints(nAgents);
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    float zOffset = (!strcasecmp(m_sGridType,"LTC")) ? 0 : 0.1 * m_fMinDistance;

    for (int i = 0; i < nAgents; i++) {
        *pts++ = *xc++;
        *pts++ = *yc++;
        *pts++ = zOffset;
    }
    
    delete aiAgentCells;
    delete xarray;
    delete yarray;

    vtkUnstructuredGrid *AgentMesh = vtkUnstructuredGrid::New();
    AgentMesh->SetPoints(Points);
    Points->Delete();
    AgentMesh->Allocate(nAgents);
    vtkIdType onevertex;
    for (int i = 0; i < nAgents; i++) {
        onevertex = i;
        AgentMesh->InsertNextCell(VTK_VERTEX, 1, &onevertex);
    }

    return AgentMesh;
}

/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetAgentIcoEqMesh(const char *popname) {
    
    // for agent positions, we need to know spatial coordinates of grid nodes

    debug1 << "QDF: [GetAgentIcoEqMesh] called GetAgentIcoEqMesh" << endl;

    double dRadius = 1.0;
    qdf_extractAttribute(m_hGeoGroup, GEO_ATTR_RADIUS, 1, &dRadius);

    GetMesh(GRIDGROUP_NAME);  // still need to call? to compute m_fMinDistance?

    dRadius = dRadius * (1 + 0.1 * m_fMinDistance);  // lift the agents over the Earth's surface for visibility

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    double *Lat = new double[nnodes];
    double *Lon = new double[nnodes];
    qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
    qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

    // correct Lat and Lon for singularities
    Lat[0] = 89.99999;
    Lat[11] = -89.99999;
    for (int i = 0; i < nnodes; i++) {
        Lon[i] = Lon[i] - 0.00001;
    }
    

    // let's read the agents' locations (cell IDs)

    int nAgents = (m_mapNAgents.find(popname))->second;
    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, SEP_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);
    hid_t hPopData = ((m_mapAgentFields.find(sCellIDName))->second).second.first;
    hid_t hCellIDType = ((m_mapAgentFields.find(sCellIDName))->second).second.second;
    
    debug1 << "QDF: [GetAgentIcoEqMesh] GetAgentIcoEqMesh preparing to read " << sCellIDName << endl;
    debug1.flush();
    int *aiAgentCells = new int[nAgents];

    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);

    debug1 << "QDF: [GetAgentIcoEqMesh] " << sCellIDName << " read: herr_t: " << iErr << endl;
    debug1.flush();

    float* xarray = new float[nAgents];
    float* yarray = new float[nAgents];
    float* zarray = new float[nAgents];
    
    double PI = 3.14159;
    
    debug1 << "QDF: [GetAgentIcoEqMesh] GetAgentIcoEqMesh preparing to read cell coords" << endl;

    // set spherical coordinates of agents
    // with tiny deviations on the tangent plane
    srand(time(NULL));
    for (int i = 0; i < nAgents; i++) {
        int iCell = aiAgentCells[i];
        float dlo = Lon[iCell] * PI / 180. + 0.25 * m_fMinDistance * GeoDeviation() / cos(Lat[iCell] * PI / 180.);
        float dla = Lat[iCell] * PI / 180. + 0.25 * m_fMinDistance * GeoDeviation();
        xarray[i] = dRadius * cos(dla) * cos(dlo);
        yarray[i] = dRadius * cos(dla) * sin(dlo);
        zarray[i] = dRadius * sin(dla);
    }
    
    
    delete Lon;
    delete Lat;
 
    // now let's create the vtk points for the point mesh
    debug1 << "QDF: [GetAgentIcoEqMesh] creating vtk points" << endl;
    
    vtkPoints *Points = vtkPoints::New();
    Points->SetNumberOfPoints(nAgents);
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    float *zc = zarray;

    for (int i = 0; i < nAgents; i++) {
        *pts++ = *xc++;
        *pts++ = *yc++;
        *pts++ = *zc++;
    }
    
    delete aiAgentCells;
    delete xarray;
    delete yarray;
    delete zarray;

    debug1 << "QDF: [GetAgentIcoEqMesh] setting Points" << endl;

    vtkUnstructuredGrid *AgentMesh = vtkUnstructuredGrid::New();
    AgentMesh->SetPoints(Points);
    Points->Delete();
    AgentMesh->Allocate(nAgents);
    vtkIdType onevertex;
    for (int i = 0; i < nAgents; i++) {
        onevertex = i;
        AgentMesh->InsertNextCell(VTK_VERTEX, 1, &onevertex);
    }

    return AgentMesh;
}


/**************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetRectMesh() {
    
    int dims[3] = {1, 1, 1};

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    char* sW = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "W", 16, sW);
    dims[0] = atoi(sW);
    delete[] sW;

    char* sH = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "H", 16, sH);
    dims[1] = atoi(sH);
    delete[] sH;
    

    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = 0;

    char* sProjG = new char[128];
    int iResult = qdf_extractSAttribute(m_hGridGroup, "PROJG", 128, sProjG);
    if ( iResult == 0) {
        float* fAtt = new float[7];
        char *sAtt = strtok(sProjG, " ");
        fAtt[0] = atof(sAtt);
        for (int i=1; i<7; i++) {
            char *sAtt = strtok(NULL, " ");  // continue scanning...
            fAtt[i] = atof(sAtt);
        }

        float fXLength = fAtt[2];
        float fYLength = fAtt[3];
        float fXCenter = fAtt[4];
        float fYCenter = fAtt[5];
        float fDeltaX  = fXLength / dims[0];
        float fDeltaY  = fYLength / dims[1];

        m_fMinDistance = (fDeltaX < fDeltaY) ? fDeltaX : fDeltaY;

        int i = 0;
        for (int y = 0; y < dims[1]; y++) {
            for (int x = 0; x < dims[0]; x++) {
                xarray[i] = x * fDeltaX + fXCenter;
                yarray[i] = y * fDeltaY + fYCenter;
                i++;
            }
        }

    } else {
    
        debug1 << "QDF: [GetRectMesh] reading lon and lat" << endl;

        double* Lat = new double[nnodes];
        double* Lon = new double[nnodes];
        
        qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
        qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);
        
        for (int i = 0; i < nnodes; i++) {
            xarray[i] = Lon[i];
            yarray[i] = Lat[i];
        }

        m_fMinDistance = fabs(Lon[1] - Lon[0]);

        delete[] Lat;
        delete[] Lon;
    }
    
    delete [] sProjG;


    vtkPoints* Points = vtkPoints::New();
    Points->SetNumberOfPoints(nnodes);
    
    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    for (int y = 0; y < dims[1]; y++) {
        for (int x = 0; x < dims[0]; x++) {
            *pts++ = *xc++;
            *pts++ = *yc++;
            *pts++ = 0.;
        }
    }
    
    vtkStructuredGrid* Grid = vtkStructuredGrid::New();
    Grid->SetPoints(Points);
    Grid->SetDimensions(dims);
    Points->Delete();

    delete[] xarray;
    delete[] yarray;
    
    return Grid;
}

/*********************************************************************/

vtkDataSet *
avtQDFFileFormat::GetHexMesh() {
    
    float hratio = 0.8660254; // sqrt(3)/2
    float offsetfactor = 0.5; 

    int dims[3] = {1, 1, 1};

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    char* sW = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "W", 16, sW);
    dims[0] = atoi(sW);
    delete[] sW;

    char* sH = new char[16];
    qdf_extractSAttribute(m_hGridGroup, "H", 16, sH);
    dims[1] = atoi(sH);
    delete[] sH;
    
    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = 0;

    char* sProjG = new char[128];
    int iResult = qdf_extractSAttribute(m_hGridGroup, "PROJG", 128, sProjG);
    if (iResult == 0) {
        float* fAtt = new float[7];
        char *sAtt = strtok(sProjG, " ");
        fAtt[0] = atof(sAtt);
        for (int i=1; i<7; i++) {
            char *sAtt = strtok(NULL, " ");  // continue scanning...
            fAtt[i] = atof(sAtt);
        }

        // FILL IN NODE COORDINATES

        float fXLength = fAtt[2];
        float fYLength = fAtt[3];
        float fXCenter = fAtt[4];
        float fYCenter = fAtt[5];
        float fDeltaX  = fXLength / dims[0];
        float fDeltaY  = /*hratio **/ fYLength / dims[1];
        float fOddRowOffset = offsetfactor * fDeltaX;

        m_fMinDistance = (fDeltaX < fDeltaY) ? fDeltaX : fDeltaY;

        int i = 0;
        for (int y = 0; y < dims[1]; y++) {
            for (int x = 0; x < dims[0]; x++) {
                xarray[i] = x * fDeltaX + fXCenter + (y % 2) * fOddRowOffset;
                yarray[i] = y * fDeltaY + fYCenter;
                i++;
            }
        }

    } else {

        double* Lat = new double[nnodes];
        double* Lon = new double[nnodes];
        
        qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
        qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

        for (int i = 0; i < nnodes; i++) {
            xarray[i] = Lon[i];
            yarray[i] = Lat[i];
        }

        m_fMinDistance = hratio * fabs(Lon[1] - Lon[0]);

        delete[] Lat;
        delete[] Lon;
    }

    delete [] sProjG;


    // CREATE VTK POINTS
   
    vtkPoints* Points = vtkPoints::New();
    Points->SetNumberOfPoints(nnodes);

    float *pts = (float *)Points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    for (int y = 0; y < dims[1]; y++) {
        for (int x = 0; x < dims[0]; x++) {
            *pts++ = *xc++;
            *pts++ = *yc++;
            *pts++ = 0.;
        }
    }
    
    delete[] xarray;
    delete[] yarray;


    // FILL IN CONNECTIVITY
    
    // there are 1 fewer rows of triangles than of nodes
    // and there are 2 * (n - 1) triangles per row, 
    // where n is the nodes in a row

    int ntriangles = (dims[1] - 1) * 2 * (dims[0] - 1); 

    int *connectivity = new int[ntriangles * 3]; 

    // order of vertices for VTK_TRIANGLE IS COUNTERCLOCKWISE
    // (surface normal points towards you)

    int j = 0;
    int iY = 0;
    while (iY < dims[1] - 1) {
        if ( (iY % 2) == 0) {
            for (int iX = 1; iX < dims[0]; iX++) {

                connectivity[j++] = iX + iY * dims[0] - 1;
                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] - 1;

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] - 1;
            }
        } else {
            for (int iX = 0; iX < dims[0] - 1; iX++) {

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + iY * dims[0] + 1;
                connectivity[j++] = iX + (iY + 1) * dims[0] + 1;

                connectivity[j++] = iX + iY * dims[0];
                connectivity[j++] = iX + (iY + 1) * dims[0] + 1;
                connectivity[j++] = iX + (iY + 1) * dims[0];
            }
        }
        iY++;
    }
 
    // Create the vtk grid object

    vtkUnstructuredGrid *Grid = vtkUnstructuredGrid::New();
    Grid->SetPoints(Points);
    Points->Delete();
    Grid->Allocate(ntriangles);

    int nverts = 3;
    vtkIdType verts[nverts];
    int *conn = connectivity;

    for (int i = 0; i < ntriangles; i++) {
        for(int j = 0; j < nverts; j++) {
            verts[j] = conn[j];
        }
        conn += nverts;
        Grid->InsertNextCell(VTK_TRIANGLE, nverts, verts);
    }

    delete[] connectivity;
    
    return Grid;
}

/************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetIcoEqMesh() {
    
    debug1 << "QDF: [GetIcoEqMesh]" << endl;

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    debug1 << "QDF: [GetIcoEqMesh] " << nnodes << " nodes" << endl;

    double dRadius = 1.0;
    qdf_extractAttribute(m_hGeoGroup, GEO_ATTR_RADIUS, 1, &dRadius);
    
    double* Lat = new double[nnodes];
    double* Lon = new double[nnodes];

    qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, Lat);
    qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, Lon);

    // correct Lat and Lon for singularities
    for (int i = 0; i < nnodes; i++) {
        if (fabs(Lat[i] - 90) < 1e-6) {
            Lat[i] = 89.99999;
        } else if (fabs(Lat[i] + 90) < 1e-6) {
            Lat[i] = -89.99999;
        }
        Lon[i] = Lon[i] - 0.00001;
    }
    
    debug1 << "QDF: [GetIcoEqMesh] Lon and Lat are ready" << endl;

    float* xarray = new float[nnodes];
    float* yarray = new float[nnodes];
    float* zarray = new float[nnodes];
    
    double PI = 3.14159;

    // set spherical coordinates of nodes

    for (int i = 0; i < nnodes; i++) {
        xarray[i] = dRadius * cos(Lat[i] * PI / 180.) * cos(Lon[i] * PI / 180.);
        yarray[i] = dRadius * cos(Lat[i] * PI / 180.) * sin(Lon[i] * PI / 180.);
        zarray[i] = dRadius * sin(Lat[i] * PI / 180.);
        //        debug5 << "QDF: [GetIcoEqMesh] (" << Lon[i] << ", " << Lat[i] << ") -> (" << xarray[i] << ", " << yarray[i] << ", " << zarray[i] << ")" << endl;
    }

 
    double* Dist = new double[nnodes*6];
    qdf_readArray(m_hGeoGroup, GEO_DS_DISTANCES, nnodes*6, Dist);
    for (int i = 0; i < nnodes*6; i++) {
        if (Dist[i] < m_fMinDistance && Dist[i] > 0) {
            m_fMinDistance = Dist[i];
        }
    }
    delete Dist;

    // FILL IN CONNECTIVITY
    EQConnectivity *pEQC =  EQConnectivity::createInstance(m_iSubDivs);
        
    int  iNTri = pEQC->getNumTriangles();
    int *piTri = pEQC->getTriangles();
    

    debug1 << "QDF: [GetIcoEqMesh] Found " << iNTri << " triangles"  << endl;

    // CREATE VTK POINTS
    
    vtkPoints* Points = vtkPoints::New();
    
    Points->SetNumberOfPoints(nnodes);

    debug1 << "QDF: [GetIcoEqMesh] Setting coords for " << nnodes << " nodes" << endl;

    float *pts = (float *)Points->GetVoidPointer(0);
    for (int i = 0; i < nnodes; i++) {
        *pts++ = xarray[i];
        *pts++ = yarray[i];
        *pts++ = zarray[i];
        //        debug5 << "QDF: " << xarray[i] << " " << yarray[i] << " " << zarray[i] << endl;
    }
    
    
    // Create a vtkUnstructuredGrid to contain the points and cells
        
    vtkUnstructuredGrid *Grid = vtkUnstructuredGrid::New();
    Grid->SetPoints(Points);
    Points->Delete();
    Grid->Allocate(iNTri);
    int nverts = 3;
    vtkIdType verts[nverts];
        
    for (int i = 0; i < iNTri; i++) {
            
        for(int j = 0; j < nverts; j++) {
            verts[j] = piTri[3 * i + j];
        }
       
    }

    for (int i = 0; i < iNTri; i++) {
            
        for(int j = 0; j < nverts; j++) {
            verts[j] = piTri[3 * i + j];
        }
        
        Grid->InsertNextCell(VTK_TRIANGLE, nverts, verts);
    }
        
    // or eeven
    //Grid->InsertNextCell(VTK_TRIANGLE, 3*iNTri, piTri);
    
    delete[] xarray;
    delete[] yarray;
    delete[] zarray;
    delete[] Lat;
    delete[] Lon;

    delete pEQC;
    debug1 << "QDF: [GetIcoEqMesh] GetIcoEqMesh returns grid (" << Grid << ")" << endl;
    return Grid;
}


/************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetNavMesh() {
    
    debug1 << "QDF: [GetNavMesh]" << endl;

    int nnodes = 0;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    debug1 << "QDF: [GetNavMesh] " << nnodes << " nodes" << endl;

    double dRadius = 1.0;
    qdf_extractAttribute(m_hGeoGroup, GEO_ATTR_RADIUS, 1, &dRadius);
    dRadius *= 1.001;
    
    double* pLat = new double[nnodes];
    double* pLon = new double[nnodes];

    qdf_readArray(m_hGeoGroup, GEO_DS_LATITUDE, nnodes, pLat);
    qdf_readArray(m_hGeoGroup, GEO_DS_LONGITUDE, nnodes, pLon);

    // correct Lat and Lon for singularities
    for (int i = 0; i < nnodes; i++) {
        if (fabs(pLat[i] - 90) < 1e-6) {
            pLat[i] = 89.99999;
        } else if (fabs(pLat[i] + 90) < 1e-6) {
            pLat[i] = -89.99999;
        }
        pLon[i] = pLon[i] - 0.00001;
    }
    
    debug1 << "QDF: [GetNavMesh] Lon and Lat are ready" << endl;

    
    double PI = 3.14159;

    uint iNumPorts = 0;
    uint iNumDests = 0;
    uint iNumDists = 0;
    qdf_extractAttribute(m_hNavGroup, NAV_ATTR_NUM_PORTS, 1, &iNumPorts);
    qdf_extractAttribute(m_hNavGroup, NAV_ATTR_NUM_DESTS, 1, &iNumDests);
    qdf_extractAttribute(m_hNavGroup, NAV_ATTR_NUM_DISTS, 1, &iNumDists);
    uint iNumBridges = 0;
    if (qdf_attr_exists(m_hNavGroup, NAV_ATTR_NUM_BRIDGES)) {
        qdf_extractAttribute(m_hNavGroup, NAV_ATTR_NUM_BRIDGES, 1, &iNumBridges);
    }


    float* xarray = new float[iNumPorts+2*iNumBridges];
    float* yarray = new float[iNumPorts+2*iNumBridges];
    float* zarray = new float[iNumPorts+2*iNumBridges];
    
    std::map<int, int> mID2Index;
    ushort *pMultiplicities = NULL;
    int *pDestinationIDs    = NULL;
    if ((iNumPorts > 0) && (iNumDests > 0)) {
        debug1 << "QDF: [GetNavMesh] doing " << iNumPorts << " island bridges" << endl;
        pMultiplicities  = new ushort[iNumPorts];
        qdf_readArray(m_hNavGroup, NAV_DS_MULTIPLICITIES, iNumPorts, pMultiplicities);

        pDestinationIDs  = new int[iNumDests];
        qdf_readArray(m_hNavGroup, NAV_DS_DEST_IDS, iNumDests, pDestinationIDs);

        // fill point coordinates and ID to index map
        int    *pCurID   = pDestinationIDs;
        for (uint i = 0; i < iNumPorts; ++i) {
            double dLon = pLon[*pCurID] * PI / 180.;
            double dLat = pLat[*pCurID] * PI / 180.;

            xarray[i] = dRadius * cos(dLat) * cos(dLon);
            yarray[i] = dRadius * cos(dLat) * sin(dLon);
            zarray[i] = dRadius * sin(dLat);

            mID2Index[*pCurID] = i;
            debug5 << "QDF: [GetNavMesh] [" << i << "] " << *pCurID <<" (" << dLon << ", " << dLat << ") -> (" << xarray[i] << ", " << yarray[i] << ", " << zarray[i] << ")" << endl;
            pCurID += pMultiplicities[i]+1;
        }
    }

    // now see if there are bridges
    int *pBridgePoints  = NULL;
    if (qdf_attr_exists(m_hNavGroup, NAV_ATTR_NUM_BRIDGES)) {
        qdf_extractAttribute(m_hNavGroup, NAV_ATTR_NUM_BRIDGES, 1, &iNumBridges);
    
        debug1 << "QDF: [GetNavMesh] trying " << iNumBridges << " bridges" << endl;
        pBridgePoints  = new int[2*iNumBridges];
        qdf_readArray(m_hNavGroup, NAV_DS_BRIDGES, 2*iNumBridges, pBridgePoints);

        int    *pCurPoint   = pBridgePoints;
        for (uint i = iNumPorts; i < iNumPorts+2*iNumBridges; ++i) {
            double dLon = pLon[*pCurPoint] * PI / 180.;
            double dLat = pLat[*pCurPoint] * PI / 180.;
            
            xarray[i] = dRadius * cos(dLat) * cos(dLon);
            yarray[i] = dRadius * cos(dLat) * sin(dLon);
            zarray[i] = dRadius * sin(dLat);
            
            mID2Index[*pCurPoint] = i;
            debug5 << "QDF: [GetNavMesh] [" << i << "] " << *pCurPoint <<" (" << dLon << ", " << dLat << ") -> (" << xarray[i] << ", " << yarray[i] << ", " << zarray[i] << ")" << endl;
            pCurPoint++;
        }
        
    }

    delete[] pLon;
    delete[] pLat;

    debug1 << "QDF: [GetNavMesh] copying " << (iNumPorts+2*iNumBridges) << " points" << endl;
    // copy points into a vtkPoints object
    vtkPoints *points = vtkPoints::New();
    points->SetNumberOfPoints(iNumPorts+2*iNumBridges);
    float *pts = (float *) points->GetVoidPointer(0);
    float *xc = xarray;
    float *yc = yarray;
    float *zc = zarray;
    for(int i = 0; i < iNumPorts+2*iNumBridges; ++i) {
        *pts++ = *xc++;
        *pts++ = *yc++;
        *pts++ = *zc++;
    }

    // Delete temporary arrays.
    delete [] xarray;
    delete [] yarray;
    delete [] zarray;



    // Create a vtkUnstructuredGrid to contain the points and cells
    
    vtkUnstructuredGrid *Grid = vtkUnstructuredGrid::New();
    Grid->SetPoints(points);
    points->Delete();
    Grid->Allocate(iNumDists+iNumPorts+2*iNumBridges);
    int nverts = 2;
    vtkIdType verts[nverts];


    // find connectivity    
    int iCheck = 0;
    if (iNumPorts > 0) {
        int *pCurID  = pDestinationIDs;

        for (uint i = 0; i < iNumPorts; ++i) {
            int iID1 = *pCurID;
            
            verts[0] =  mID2Index[*pCurID++];
            debug1 << "QDF: [GetNavMesh] for " << verts[0] << "(" << iID1 << ") : " <<  pMultiplicities[i] << " connections" << endl;
            Grid->InsertNextCell(VTK_VERTEX, 1, verts);
            for (int j = 0; j < pMultiplicities[i]; j++) {
                int iID2 = *pCurID;
                verts[1] =  mID2Index[*pCurID++];
                
                debug1 << "QDF: [GetNavMesh] added " << verts[0] << "(" << iID1 << ") -- " << verts[1] << "(" << iID2 << ")" << endl;
                
                Grid->InsertNextCell(VTK_LINE, nverts, verts);
                iCheck++;
            }
        }    
    }
   
    if (iNumBridges > 0) {
        int *pCurPoint = pBridgePoints;
        debug1 << "QDF: [GetNavMesh] loop from  " << iNumPorts << " to " << iNumPorts+2*iNumBridges << endl;
        for (uint i = iNumPorts; i < iNumPorts+2*iNumBridges; i+=2) {
            int iID1 = *pCurPoint++;
            int iID2 = *pCurPoint++;
            
            verts[0] =  mID2Index[iID1];
            verts[1] =  mID2Index[iID2];
            debug1 << "QDF: [GetNavMesh] added bridge " << verts[0] << "(" << iID1 << ") -- " << verts[1] << "(" << iID2 << ")" << endl;
            Grid->InsertNextCell(VTK_VERTEX, 1, verts);
            Grid->InsertNextCell(VTK_LINE, nverts, verts);
            iCheck++;
        }    
    }
    

    debug1 << "QDF: [GetNavMesh] created " << iCheck << " lines" << endl;
    delete[] pMultiplicities;
    delete[] pDestinationIDs;
    if (pBridgePoints != NULL){
        delete[] pBridgePoints;
    }

    return Grid;

}




/************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetPieMesh(const char *meshname) {
    
    debug1 << "QDF: [GetPieMesh] (this:" << this <<") called with meshname [" << meshname << "]" << endl;
    vtkUnstructuredGrid *PieMesh = NULL;

    std::string sName = meshname;

    sName = sName.substr(0, sName.find("_mesh"));
    debug1 << "QDF: [GetPieMesh] pie name: " << sName << endl;

    hid_t hPieSubGroup = getHandle(m_mapPieSubGroups, sName.c_str());
    if (hPieSubGroup != H5P_DEFAULT) {
        long iNumPies = 0;
        long iNumVals = 0;
        int iResult = 0;
    
        debug1 << "QDF: [GetPieMesh]  getting attributes & dataset " << endl<< std::flush;

        if (iResult == 0) {

            iResult = qdf_extractAttribute(hPieSubGroup, PIE_ATTR_NUM_PIES, 1, &iNumPies);
            if (iResult != 0) {
                debug1 << "QDF: [GetPieMesh] Attribute [" << PIE_ATTR_NUM_PIES << "] does not exist" << endl << std::flush;
            } else {
                debug1 << "QDF: [GetPieMesh]  numpies: " << iNumPies  << endl<< std::flush;
            }
        }
        if (iResult == 0) {
            iResult = qdf_extractAttribute(hPieSubGroup, PIE_ATTR_NUM_VALS, 1, &iNumVals);
            if (iResult != 0) {
                debug1 << "QDF: [GetPieMesh] Attribute [" << PIE_ATTR_NUM_VALS << "] does not exist" << endl << std::flush;
            } else {
                debug1 << "QDF: [GetPieMesh]  numvals: " << iNumVals  << endl<< std::flush;
            }
        }
        debug1 << "QDF: [GetPieMesh] " << sName << " has " << iNumPies << " pies with " << iNumVals << " values" << endl << std::flush;
    
        if (iResult == 0) {
            int nItems = iNumPies*(6+iNumVals);
            double* pData = new double[nItems]; // pos(3), norm(3), vals (numvals
        
            qdf_readArray(hPieSubGroup, PIE_DATASET_NAME, nItems, pData);
        
            debug1 << "QDF: [GetPieMesh] copying " << iNumPies << " points" << endl << std::flush;
            // copy points into a vtkPoints object
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(iNumPies);
            float *pts = (float *) points->GetVoidPointer(0);
        
        
            double *pCur = pData;
            for (uint i = 0; i < iNumPies; ++i) {
                *pts++ = *pCur++;
                *pts++ = *pCur++;
                *pts++ = *pCur++;
                pCur += 3+iNumVals; // maybe out again
            }
   
            // Create a vtkUnstructuredGrid to contain the points and cells
        
            PieMesh = vtkUnstructuredGrid::New();
            PieMesh->SetPoints(points);
            points->Delete();
            PieMesh->Allocate(iNumPies);
            vtkIdType onevertex;
            for (int i = 0; i < iNumPies; i++) {
                onevertex = i;
            }
        }
    } else {
        debug1 << "QDF: [GetPieMesh] name [" <<sName<< "] dos not exist as a pie group" << endl << std::flush;
    }
    debug1 << "QDF: [GetPieMesh] exting with(" << PieMesh << ")" << endl << std::flush;

    return PieMesh;

}


/************************************************************************/

vtkDataSet *
avtQDFFileFormat::GetVecMesh(const char *meshname) {
    
    debug1 << "QDF: [GetVecMesh] called with meshname [" << meshname << "]" << endl;

    vtkUnstructuredGrid *VecMesh = NULL;
    
    int iResult = 0;
    std::string sName = meshname;

    sName = sName.substr(0, sName.find("_mesh"));
    debug1 << "QDF: [GetVecMesh] vec name: " << sName << endl;
   
    hid_t hVecSubGroup = getHandle(m_mapVecSubGroups, sName.c_str());
    if (hVecSubGroup != H5P_DEFAULT) {    
        long iNumVecs = 0;
    
        if (iResult == 0) {
            iResult = qdf_extractAttribute(hVecSubGroup, VEC_ATTR_NUM_VECS, 1, &iNumVecs);
            if (iResult != 0) {
                debug1 << "QDF: [GetVecMesh] Attribute [" << VEC_ATTR_NUM_VECS << "] does not exist" << endl << std::flush;
            } else {
                debug1 << "QDF: [GettVecMesh]  numvecs: " << iNumVecs  << endl<< std::flush;
            }
        }


        if (iResult == 0) {
            int nItems = iNumVecs*6;
            double* pData = new double[nItems]; // pos(3), dir(3)
        
            iResult = qdf_readArray(hVecSubGroup, VEC_DATASET_NAME, nItems, pData);
            if (iResult != 0) {
                debug1 << "QDF: [GetVecMesh] array [" << VEC_DATASET_NAME << "] does not exist" << endl << std::flush;
            } else {
                debug1 << "QDF: [GetVecMesh] array [" << VEC_DATASET_NAME << "] read ok" << endl << std::flush;
            }

            debug1 << "QDF: [GetVecMesh] copying " << iNumVecs << " points" << endl << std::flush;
            // copy points into a vtkPoints object
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(iNumVecs);
            float *pts = (float *) points->GetVoidPointer(0);
        
        
            double *pCur = pData;
            for (uint i = 0; i < iNumVecs; ++i) {
                *pts++ = *pCur++;
                *pts++ = *pCur++;
                *pts++ = *pCur++;
                pCur +=3;
            }
   
            // Create a vtkUnstructuredGrid to contain the points and cells
        
            VecMesh = vtkUnstructuredGrid::New();
            VecMesh->SetPoints(points);
            points->Delete();
            VecMesh->Allocate(iNumVecs);
            vtkIdType onevertex;
            for (int i = 0; i < iNumVecs; i++) {
                onevertex = i;
            }
        }
    } else {
        debug1 << "QDF: [GetVecMesh] [" << sName << "] is not a vec subgroup name" << endl << std::flush;
    }
    debug1 << "QDF: [GetVecMesh] exting with(" << VecMesh << ")" << endl << std::flush;
       
    return VecMesh;

}


// ****************************************************************************
//  Method: avtQDFFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: simone -- generated by xml2avt
//  Creation:   Mon Mar 3 15:13:58 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtQDFFileFormat::GetVar(const char *varname)
{
    vtkDataArray* Var = NULL;
    debug1 << "QDF: [GetVar] (\"" << varname << "\")"<< endl;

    debug1 << "QDF: [GetVar] md " << metadata << endl;

    if (m_mapSpecialAgentVars.size() == 0) {
        //        PopulateDatabaseMetaData(metadata);
    }

    if (strcasecmp(varname, GEO_DS_ALTITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_LONGITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_LATITUDE) == 0 ||
        strcasecmp(varname, GEO_DS_AREA) == 0 ||
        strcasecmp(varname, GEO_DS_WATER) == 0 ||
        strcasecmp(varname, GEO_DS_ICE_COVER) == 0 ||
        strcasecmp(varname, GEO_DS_COASTAL) == 0) {
        debug1 << "QDF: [GetVar]   Geo Thing" << endl;
        // geography variables
        if (m_hGeoGroup > 0) {
            Var = GetQDFScalar(m_hGeoGroup, varname);
        }
    } else if (strstr(varname, GEO_DS_ANGLES) == varname) {
        debug1 << "QDF: [GetVar]   Geo Thing" << endl;
        // geography variables
        if (m_hGeoGroup > 0) {
            Var = GetQDFScalarMulti(m_hGeoGroup, varname);
        }
        

    } else if (strcasecmp(varname, CLI_DS_ACTUAL_TEMPS) == 0 ||
               strcasecmp(varname, CLI_DS_ACTUAL_RAINS) == 0 ||
               strcasecmp(varname, CLI_DS_ANN_MEAN_TEMP) == 0 ||
               strcasecmp(varname, CLI_DS_ANN_TOT_RAIN) == 0 ||
               strcasecmp(varname, CLI_DS_CUR_SEASON) == 0) {

        debug1 << "QDF: [GetVar]   Climate Thing" << endl;
        
        // climate variables
        if (m_hClimateGroup > 0) {
            Var = GetQDFScalar(m_hClimateGroup, varname);
        }

    } else if ((strcasecmp(varname, VEG_DS_NPP) == 0) ||
               (strcasecmp(varname, VEG_DS_BASE_NPP) == 0)) {
        debug1 << "QDF: [GetVar]   Vegetation Thing" << endl;
        
        // climate variables
        if (m_hVegGroup > 0) {
            Var = GetQDFScalar(m_hVegGroup, varname);
        }


    } else  if (strcasecmp(varname, "pietest") == 0) {
        // used to be "zombone"
        Var = GetVectorVar(varname);

    } else {
        debug1 << "QDF: [GetVar]   Veg or agentvar Thing" << endl;

        // vegetation or agent variables
        char *name = new char[128];
        strcpy(name,varname);
        char *pLast = strrchr(name, SEP_CHAR[0]);

        if (pLast != NULL) {
            *pLast = '\0';
            pLast++;
        }
        debug1 << "QDF: [GetVar]   name [" << name << "], pLast [" <<pLast << "]" << endl;

        if (strcmp(name, VEG_DS_BASE_NPP) == 0 ||
            strcmp(name, VEG_DS_NPP) == 0) {
            debug1 << "QDF:   Veg Thing" << endl;
            // vegetation variables
            Var = GetQDFVegScalar(varname);

        } else {
            debug1 << "QDF: [GetVar] last: " << pLast << endl;
            if (strcmp(pLast, NUMBER_NAME) == 0) {
            
                debug1 << "QDF: [GetVar] displaying (GetQDFAgentNumber) " << varname << endl;
                // agent densities are "special"
                Var = GetQDFAgentNumber(varname);
                
            } else {
                
                debug1 << "QDF: [GetVar] displaying (GetQDFPopScalar) " << varname << endl;
                Var = GetQDFPopScalar(varname);
                
                /*
                bool bSearching = true;
                for (uint i = 0; bSearching && (i < m_vSpecialNames.size()); i++) {
                    if (strstr(pLast, m_vSpecialNames[i].c_str()) == pLast) {
                        bSearching = false;
                    }
                } 
                */  
                /*        
                debug1 << "QDF: [GetVar] comparing[" << pLast << "] to [" << CAP_NAME << "], ["<< ARRIVAL_NAME << "], ["<< DISTANCE_NAME << "], ["<< HOPS_NAME << "], ["<< HYBR_NAME << "], ["<< "GrassMassAvail" << "]" << endl <<std::flush;
                debug1 << "QDF: [GetVar] special names: ";
                for (uint i = 0; i < m_vSpecialNames.size(); i++) {
                    debug1 << "[" <<m_vSpecialNames[i] << "] ";
                }
                debug1 << endl << std::flush;

                if ((strstr(pLast, CAP_NAME) == pLast) || 
                    (strstr(pLast, ARRIVAL_NAME) == pLast) ||
                    (strstr(pLast, DISTANCE_NAME) == pLast) ||
                    (strstr(pLast, HOPS_NAME) == pLast)||
                    (strstr(pLast, HYBR_NAME) == pLast)||
                    (strstr(pLast, HYBR_NAME) == pLast)||
                    (strstr(pLast, "GrassMassAvail") == pLast))  {
                    
                    //                if (!bSearching) {
                    // other agent scalars
                    debug1 << "QDF: [GetVar] displaying (GetQDFPopScalar) " << varname << endl;
                    Var = GetQDFPopScalar(varname);
                }
                */
            }
        }
        

        // don't delete or it crashes...
        // delete name;
        // delete subs;
    }

    
    return Var;
}

/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFScalar(hid_t hGroup, const char* varname) {
    debug1 << "QDF: [GetQDFScalar] (this:" << this <<") for [" << varname << "]" << endl;
    vtkDataArray* Scalar = NULL;

    int nnodes = -1;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    hid_t dataset = H5Dopen(hGroup, varname, H5P_DEFAULT); 
    hid_t datatype = H5Dget_type(dataset); 
    int ncheck = H5Dget_storage_size(dataset) / H5Tget_size(datatype);
    
    if (ncheck == nnodes) {
        hid_t native_type = H5Tget_native_type(datatype, H5T_DIR_DESCEND); 
        
        if (H5Tequal(H5T_NATIVE_DOUBLE, native_type)) {
            debug1 << "QDF: [GetQDFScalar] loading double" << endl;
            
            Scalar = vtkDoubleArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            double* pData = (double *)Scalar->GetVoidPointer(0);
            
            qdf_readArray(hGroup, varname, nnodes, pData);
            
        } else if (H5Tequal(H5T_NATIVE_INT, native_type)) {
            debug1 << "QDF: [GetQDFScalar] loading int" << endl;

            Scalar = vtkIntArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            int* pData = (int *)Scalar->GetVoidPointer(0);

            qdf_readArray(hGroup, varname, nnodes, pData);

        } else if (H5Tequal(H5T_NATIVE_UCHAR, native_type) ||
                   H5Tequal( H5T_STD_I8LE, native_type)) {
            debug1 << "QDF: [GetQDFScalar] loading uchar" << endl;

            Scalar = vtkUnsignedCharArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            unsigned char* pData = (unsigned char*)Scalar->GetVoidPointer(0);

            qdf_readArray(hGroup, varname, nnodes, pData);

        }
    }
    return Scalar;
}  


/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFScalarMulti(hid_t hGroup, const char* varname) {
    debug1 << "QDF: [GetQDFScalarMulti] for [" << varname << "] it is" << endl << std::flush;

    vtkDataArray* Scalar = NULL;

    char sName[128];
    strcpy(sName, varname);
    char *pIndex = strchr(sName, '_');
    int iIndex = 0;
    debug1 << "QDF: [GetQDFScalarMulti]  pIndex[" << pIndex <<"] iIndex:" << iIndex << endl << std::flush;
    if (pIndex != NULL) {
        *pIndex = '\0';
        pIndex++;
        iIndex = atoi(pIndex);
    }
    int nnodes = -1;
    debug1 << "QDF: [GetQDFScalarMulti] name [" << sName << "], index:" << iIndex << endl << std::flush;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    debug1 << "QDF: [GetQDFScalarMulti] nnodes:" << nnodes << endl << std::flush;
    
    hid_t dataset = H5Dopen(hGroup, sName, H5P_DEFAULT); 
    hid_t datatype = H5Dget_type(dataset); 
    int ncheck = H5Dget_storage_size(dataset) / H5Tget_size(datatype);

    debug1 << "QDF: [GetQDFScalarMulti] ncheck:" << ncheck << "; 6*nnodes=" << (6*nnodes) << endl << std::flush;
    
    if (ncheck == 6*nnodes) {
        hid_t native_type = H5Tget_native_type(datatype, H5T_DIR_DESCEND); 
        
        if (H5Tequal(H5T_NATIVE_DOUBLE, native_type)) {
            debug1 << "QDF: [GetQDFScalarMulti] double" << endl << std::flush;
            
            Scalar = vtkDoubleArray::New();
            Scalar->SetNumberOfTuples(nnodes);
            double* pData = (double *)Scalar->GetVoidPointer(0);

            debug1 << "QDF: [GetQDFScalarMulti:slabbing] [" << sName << "] nnodes:" << nnodes << " offset:" << iIndex << " stride:6" << endl<< std::flush;
            
            qdf_readArraySlabT(hGroup, sName, nnodes, iIndex, 6, 1, pData);
            
        } else {
            debug1 << "QDF: [GetQDFScalarMulti] type is not double" << endl << std::flush;
        }
    }
    return Scalar; 
}
        
/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFVegScalar(const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hVegGroup, VEG_ATTR_NUM_CELLS, 1, &nnodes);

    int vegtype = -1;
    
    char *name = new char[128];
    strcpy(name,varname);
    char *pType = strrchr(name, SEP_CHAR[0]);
    if (pType != NULL) {
        *pType = '\0';
        pType++;
        vegtype = atoi(pType);
    }
    

    double **pDummy = new double*[m_nVegSpecies];
    for (int i = 0; i < m_nVegSpecies; i++) {
        pDummy[i] = new double[nnodes];
    }
    qdf_readArrays(m_hVegGroup, name, m_nVegSpecies, nnodes, pDummy);

    vtkDoubleArray* Scalar = vtkDoubleArray::New();
    Scalar->SetNumberOfTuples(nnodes);
    double* pData = (double*)Scalar->GetVoidPointer(0);
    
    for (int i = 0; i < nnodes; i++) {
        *pData++ = pDummy[vegtype][i];
    }
    
    

    return Scalar;
}




/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFAgentNumber(const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    vtkIntArray* Scalar = vtkIntArray::New();
    Scalar->SetNumberOfTuples(nnodes);
    int* pData = (int *)Scalar->GetVoidPointer(0);
           
    for (int i = 0; i < nnodes; i++) {
        pData[i] = 0;
    }
        
    char* popname = new char[128];
    strcpy(popname, varname);
    char *pLast = strrchr(popname, SEP_CHAR[0]);
    *pLast = '\0';
      
    debug1 << "QDF: [GetQDFAgentNumber] getting number density for " << popname << endl;

    int nAgents = m_mapNAgents.find(popname)->second;
            
    char* sCellIDName = new char[128];
    strcpy(sCellIDName, popname);
    strcat(sCellIDName, SEP_CHAR);
    strcat(sCellIDName, GRID_DS_CELL_ID);

    std::map< std::string, name_group>::iterator it = m_mapAgentFields.find(sCellIDName);

    hid_t hPopData = (it->second).second.first;
    hid_t hCellIDType = (it->second).second.second;
            
    int *aiAgentCells = new int[nAgents];
            
    herr_t iErr = H5Dread(hPopData, hCellIDType, H5S_ALL, H5S_ALL, H5P_DEFAULT, aiAgentCells);
                
    if (iErr < 0) {
        debug1 << "QDF: [GetQDFAgentNumber] could not read data" << endl;
    }
    else {

        debug1 << "QDF: [GetQDFAgentNumber] data has been read, now filling in vtkIntArray for " << nnodes << " nodes" << endl;

        for (int i = 0; i < nAgents; i++) {
            int iCell = aiAgentCells[i];
            //            debug1 << "QDF: counted one agent in cell " << iCell << endl;
            if (iCell < nnodes) {
                pData[iCell] += 1;
            } else {
                debug1 << "QDF: [GetQDFAgentNumber] crazy cell ID " << iCell << ", maximum is " << nnodes << endl;
            }
        }
    }

    for (int i = 0; i < nnodes; i++) {
        if (pData[i] > 0) {
            debug1 << "QDF: [GetQDFAgentNumber] Cell " << i << ": " << pData[i] << " nodes" << endl;
        }
    }
    
    delete aiAgentCells;

    // why does it crash if I delete these?
    // delete name;
    // delete popname;

    return Scalar;
}


/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFPopScalar(const char* varname) {

    int nnodes = -1;
    qdf_extractAttribute(m_hGridGroup, GRID_ATTR_NUM_CELLS, 1, &nnodes);
    
    vtkDoubleArray* Scalar = vtkDoubleArray::New();
    Scalar->SetNumberOfTuples(nnodes);
    double* pData = (double *)Scalar->GetVoidPointer(0);
          
    
    debug1 << "QDF: [GetQDFPopScalar] (this:" << this <<") getting info for [" << varname << "]" << endl;
    
    int iRes = -1;

    std::map< std::string, truename_group>::iterator it;
    debug1 << "QDF: [GetQDFPopScalar] number of items: " << m_mapSpecialAgentVars.size() << endl;
    for (it = m_mapSpecialAgentVars.begin(); it != m_mapSpecialAgentVars.end(); ++it) {
        debug1 << "QDF: [GetQDFPopScalar]  " << it->first << " => (" << it->second.first << ", " << it->second.second << ")" << endl;
    }

    it = m_mapSpecialAgentVars.find(varname);
    if (it != m_mapSpecialAgentVars.end()) {
        debug1 << "QDF: [GetQDFPopScalar] found entry for [" << varname << "]: (" << it->second.first << ", " << it->second.second << ")" << endl;

        const char *pPath = it->second.first.c_str();
        debug1 << "QDF: [GetQDFPopScalar] truename for [" << varname << "] : [" << pPath << "]" << endl;
        hid_t hPopGroup = it->second.second;
        debug1 << "QDF: [GetQDFPopScalar] hPopGroup for [" << varname << "] : [" << hPopGroup << "]" << endl;

        
        debug1 << "QDF: [GetQDFPopScalar] trying to read array [" << pPath << "] in pop group: " << hPopGroup << endl<< std::flush;
                
        iRes = qdf_readArray(hPopGroup, pPath, nnodes, pData);

        std::string sItems = "";
        for (int i = 0; i < nnodes; i++) {
            sItems += ",  ";
            char sData[256];
            sprintf(sData, "%f", pData[i]);
            sItems += sData;
            if ((i+1)%10 == 0) {
                debug1 << "QDF: [GetQDFPopScalar] pData:" << sItems<< endl <<std::flush;
                sItems = "";
            }
        }
        if (!sItems.empty()) {
            debug1 << "QDF: [GetQDFPopScalar] pData:" << sItems<< endl <<std::flush;
        }
            
        debug1 << "QDF: [GetQDFPopScalar] res: "<< iRes << "; first items: " << pData[0] << ", "<< pData[1] << ", "<< pData[2] << ", "<< pData[3] << ", " << endl<< std::flush;
    } else {
        debug1 << "QDF: [GetQDFPopScalar] no name(" << varname << "),hPopData for [" << it->first << "]" << endl<< std::flush;
    }
                
    if (iRes < 0) {
        debug1 << "QDF: [GetQDFPopScalar] could not read data" << endl;
    }
    else {

        debug1 << "QDF: [GetQDFPopScalar] data has been read" << endl;

    }

    // why does it crash if I delete these?
    // delete name;
    // delete popname;

    return Scalar;
}

/***********************************************************************/

vtkDataArray*
avtQDFFileFormat::GetQDFAgentScalar(const char* varname) {
    vtkDataArray* Scalar = NULL;

    std::map< std::string, name_group>::iterator it = m_mapAgentFields.find(varname);
    hid_t hDataSet = (it->second).second.first;
    hid_t tCompoundFieldType = (it->second).second.second;
    // the data field type is a "fake" compound type that contains only one member...
    hid_t tFieldType = H5Tget_member_type(tCompoundFieldType, 0); 

    char* popname = new char[128];
    strcpy(popname, varname);
    char* pLast = strrchr(popname, SEP_CHAR[0]);

    int nAgents = (m_mapNAgents.find(popname))->second;

    debug1 << "QDF: [GetQDFAgentScalar] get scalar " << varname << " for " << nAgents << " agents" << endl;
    
    hid_t native_type = H5Tget_native_type(tFieldType, H5T_DIR_DESCEND); 

    if (H5Tequal(H5T_NATIVE_DOUBLE, native_type)) {
        
        debug1 << "QDF: [GetQDFAgentScalar] double scalar" << endl;

        Scalar = vtkDoubleArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        double* pData = (double *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        
    } else if (H5Tequal(H5T_NATIVE_FLOAT, native_type)) {

        debug1 << "QDF: [GetQDFAgentScalar] float scalar" << endl;

        Scalar = vtkFloatArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        float* pData = (float *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
             
    } else if (H5Tequal(H5T_NATIVE_INT, native_type)) {

        debug1 << "QDF: [GetQDFAgentScalar] int scalar" << endl;

        Scalar = vtkIntArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        int* pData = (int *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
        
    } else if (H5Tequal(H5T_NATIVE_LONG, native_type)) {

        debug1 << "QDF: [GetQDFAgentScalar] long int scalar" << endl;

        Scalar = vtkLongArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        long int* pData = (long int *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
                
    } else if (H5Tequal(H5T_NATIVE_UCHAR, native_type)) {

        debug1 << "QDF: [GetQDFAgentScalar] unsigned 8-bit scalar" << endl;

        Scalar = vtkUnsignedCharArray::New();
        Scalar->SetNumberOfTuples(nAgents);
        unsigned char* pData = (unsigned char *)Scalar->GetVoidPointer(0);
        H5Dread(hDataSet, tCompoundFieldType, H5S_ALL, H5S_ALL, H5P_DEFAULT, pData);
                
    } 
    return Scalar;
}    


// ****************************************************************************
//  Method: avtQDFFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: jody
//  Creation:   Oct 11 2021
//
// ****************************************************************************

vtkDataArray *
avtQDFFileFormat::GetVectorVar(const char *varname)
{
    vtkDataArray *rv = NULL;
    debug1 << "QDF: [GetQDFVectorVar] called for var [" << varname << "]" << endl << std::flush;
    rv = GetQDFPieVectorVar(varname);
    if (rv == NULL) {
        rv = GetQDFVecVectorVar(varname);
    }
    return rv;
}

vtkDataArray *
avtQDFFileFormat::GetQDFPieVectorVar(const char *varname)
{
    vtkDoubleArray *rv = 0;
    debug1 << "QDF: [GetQDFPieVectorVar] called for var [" << varname << "]" << endl << std::flush;

    hid_t hPieSubGroup = getHandle(m_mapPieSubGroups, varname);
    if (hPieSubGroup != H5P_DEFAULT) {
        long iNumPies = 0;
        long iNumVals = 0;

        int iResult = 0;

        if (iResult == 0) {
    
            iResult = qdf_extractAttribute(hPieSubGroup, PIE_ATTR_NUM_PIES, 1, &iNumPies);
            if (iResult != 0) {
                debug1 << "QDF: [GetQDFPieVectorVar] Attribute [" << PIE_ATTR_NUM_PIES << "] does not exist" << endl << std::flush;
            }
        }
        if (iResult == 0) {
            iResult = qdf_extractAttribute(hPieSubGroup, PIE_ATTR_NUM_VALS, 1, &iNumVals);
            if (iResult != 0) {
                debug1 << "QDF: [GetQDFPieVectorVar] Attribute [" << PIE_ATTR_NUM_VALS << " does not exist" << endl << std::flush;
            }
        }

        if (iResult == 0) {
            int iNumComp = 6+iNumVals;
            std::vector<std::string> vCompNames {"pos_x", "pos_y", "pos_z", "norm_x", "norm_y", "norm_z"};
    
            int nItems = iNumPies*(6+iNumComp);
            double* pData = new double[nItems]; // pos(3), norm(3), vals (numvals

            debug1 << "QDF: [GetQDFPieVectorVar] reading " << nItems << " doubles from dataset [" << PIE_DATASET_NAME << "]" << endl << std::flush;
        
            qdf_readArray(hPieSubGroup, PIE_DATASET_NAME, nItems, pData);

            debug1 << "QDF: [GetQDFPieVectorVar] have " << iNumPies << " tuples with " << iNumComp << " components" << endl << std::flush;
        

            // we expect the string named "PIE_ATTR_VAL_NAMES" to contain the valuenames separated by '#'
            char sComponentNames[1024];
            qdf_extractSAttribute(hPieSubGroup, PIE_ATTR_VAL_NAMES, 1024, sComponentNames);
            debug1 << "QDF: [GetQDFPieVectorVar] got val names [" << sComponentNames <<"]" << endl <<std::flush;
            char *p = strtok(sComponentNames, ";"); 
            while (p != NULL) {
                vCompNames.push_back(p);
                p = strtok(NULL, ";");
            }
            debug1 << "QDF: [GetQDFPieVectorVar] in total " << vCompNames.size() <<" names" << endl <<std::flush;
        
            rv = vtkDoubleArray::New();
            rv->SetNumberOfComponents(iNumComp);
            rv->SetNumberOfTuples(iNumPies);
            double *pCur = pData;
            for (uint i = 0; i < iNumPies; i++) {
                rv->SetTuple(i, pCur); 
                pCur += iNumComp;
            }
            int iNumCN = iNumComp - 6;
            if (iNumComp > vCompNames.size()) {
                iNumCN = vCompNames.size();
            }
            for (uint i = 0; i < iNumComp; i++) {
                debug1 << "QDF: [GetQDFPieVectorVar] setting valname #" << i << " to [" << vCompNames[i] <<"]" <<endl <<std::flush;
                rv->SetComponentName(i, vCompNames[i].c_str());
            }
            debug1 << "QDF: [GetQDFPieVectorVar] pieset ["<< varname << "] created " << endl << std::flush;
        } else {
            debug1 << "QDF: [GetQDFPieVectorVar] pieset ["<< varname << "] not really created" << endl << std::flush;
        }
    } else {
        debug1 << "QDF: [GetQDFPieVectorVar]  ["<< varname << "] s not the name of a pie sugroup" << endl << std::flush;
    }

    return rv;
}


vtkDataArray *
avtQDFFileFormat::GetQDFVecVectorVar(const char *varname)
{
    vtkDoubleArray *rv = 0;
    debug1 << "QDF: [GetQDFVecVectorVar] called for var [" << varname << "]" << endl << std::flush;

    hid_t hVecSubGroup = getHandle(m_mapVecSubGroups, varname);
    if (hVecSubGroup != H5P_DEFAULT)  {
        long iNumVecs = 0;
        long iNumVals = 0;
        int iNumComp  = 6;
        int iResult = 0;

        iResult = qdf_extractAttribute(hVecSubGroup, VEC_ATTR_NUM_VECS, 1, &iNumVecs);
        if (iResult != 0) {
            debug1 << "QDF: [GetQDFPieVectorVar] Attribute [" << VEC_ATTR_NUM_VECS << "] does not exist" << endl << std::flush;
        }
        double* pData = new double[iNumVecs*iNumComp]; // pos(3), norm(3)
        iResult = qdf_readArray(hVecSubGroup, VEC_DATASET_NAME, iNumVecs, pData);
        if (iResult != 0) {
            debug1 << "QDF: [GetQDFPieVectorVar] Attribute [" << VEC_DATASET_NAME << "] does not exist" << endl << std::flush;
        }

        debug1 << "QDF: [GetQDFVecVectorVar] have " << iNumVecs << " tuples with " << iNumComp << " components" << endl << std::flush;
        


        if (iResult == 0) {
        
        
            rv = vtkDoubleArray::New();
            rv->SetNumberOfComponents(3);
            rv->SetNumberOfTuples(iNumVecs);
            double *pCur = pData;
        
            for (uint i = 0; i < iNumVecs; i++) {
                debug1 << "QDF: [GetQDFVectorVar] Tuple "<< i << ": " << pCur[0] << " " << pCur[1] << " " << pCur[2] << "   " << pCur[3] << " " << pCur[4] << " " << pCur[5] << endl << std::flush; 
                rv->SetTuple(i, pCur+3); 
                pCur += iNumComp;
            }
            debug1 << "QDF: [GetQDFVectorVar] vecset ["<< varname << "] created " << endl << std::flush;
        } else {
            debug1 << "QDF: [GetQDFVectorVar] vecset ["<< varname << "] not really created" << endl << std::flush;
        }
    } else {
        debug1 << "QDF: [GetQDFVectorVar]  ["<< varname << "] does not exist as a vec subgroup name" << endl << std::flush;
    } 

    return rv;
}


    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
    //}
